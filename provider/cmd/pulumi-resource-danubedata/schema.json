{
    "name": "danubedata",
    "displayName": "DanubeData",
    "description": "A Pulumi provider for managing DanubeData cloud infrastructure resources.",
    "keywords": [
        "pulumi",
        "danubedata",
        "category/cloud",
        "kind/native"
    ],
    "homepage": "https://danubedata.ro",
    "license": "Apache-2.0",
    "attribution": "This Pulumi package is based on the [`danubedata` Terraform Provider](https://github.com/AdrianSilaghi/terraform-provider-danubedata).",
    "repository": "https://github.com/AdrianSilaghi/pulumi-danubedata",
    "pluginDownloadURL": "github://api.github.com/AdrianSilaghi/pulumi-danubedata",
    "publisher": "AdrianSilaghi",
    "meta": {
        "moduleFormat": "(.*)(?:/[^/]*)"
    },
    "language": {
        "csharp": {
            "packageReferences": {
                "Pulumi": "3.*"
            },
            "namespaces": {
                "danubedata": "DanubeData"
            },
            "compatibility": "tfbridge20",
            "rootNamespace": "DanubeData"
        },
        "go": {
            "importBasePath": "github.com/AdrianSilaghi/pulumi-danubedata/sdk/go/danubedata",
            "generateResourceContainerTypes": true,
            "generateExtraInputTypes": true
        },
        "nodejs": {
            "packageName": "@danubedata/pulumi",
            "packageDescription": "A Pulumi provider for managing DanubeData cloud infrastructure resources.",
            "readme": "\u003e This provider is a derived work of the [Terraform Provider](https://github.com/AdrianSilaghi/terraform-provider-danubedata)\n\u003e distributed under [MPL 2.0](https://www.mozilla.org/en-US/MPL/2.0/). If you encounter a bug or missing feature,\n\u003e first check the [`pulumi-danubedata` repo](https://github.com/AdrianSilaghi/pulumi-danubedata/issues); however, if that doesn't turn up anything,\n\u003e please consult the source [`terraform-provider-danubedata` repo](https://github.com/AdrianSilaghi/terraform-provider-danubedata/issues).",
            "dependencies": {
                "@pulumi/pulumi": "^3.0.0"
            },
            "devDependencies": {
                "@types/node": "^10.0.0"
            },
            "compatibility": "tfbridge20",
            "disableUnionOutputTypes": true
        },
        "python": {
            "packageName": "pulumi_danubedata",
            "requires": {
                "pulumi": "\u003e=3.0.0,\u003c4.0.0"
            },
            "readme": "\u003e This provider is a derived work of the [Terraform Provider](https://github.com/AdrianSilaghi/terraform-provider-danubedata)\n\u003e distributed under [MPL 2.0](https://www.mozilla.org/en-US/MPL/2.0/). If you encounter a bug or missing feature,\n\u003e first check the [`pulumi-danubedata` repo](https://github.com/AdrianSilaghi/pulumi-danubedata/issues); however, if that doesn't turn up anything,\n\u003e please consult the source [`terraform-provider-danubedata` repo](https://github.com/AdrianSilaghi/terraform-provider-danubedata/issues).",
            "compatibility": "tfbridge20",
            "pyproject": {}
        }
    },
    "config": {
        "variables": {
            "apiToken": {
                "type": "string",
                "description": "API token for DanubeData authentication. Can also be set via DANUBEDATA_API_TOKEN environment variable.\n",
                "defaultInfo": {
                    "environment": [
                        "DANUBEDATA_API_TOKEN"
                    ]
                },
                "secret": true
            },
            "baseUrl": {
                "type": "string",
                "description": "Base URL for the DanubeData API. Defaults to https://danubedata.ro/api/v1. Can also be set via DANUBEDATA_BASE_URL\nenvironment variable.\n",
                "default": "https://danubedata.ro/api/v1",
                "defaultInfo": {
                    "environment": [
                        "DANUBEDATA_BASE_URL"
                    ]
                }
            }
        }
    },
    "types": {
        "danubedata:index/CacheTimeouts:CacheTimeouts": {
            "properties": {
                "create": {
                    "type": "string",
                    "description": "Time to wait for cache creation.\n"
                },
                "delete": {
                    "type": "string",
                    "description": "Time to wait for cache deletion.\n"
                },
                "update": {
                    "type": "string",
                    "description": "Time to wait for cache updates.\n"
                }
            },
            "type": "object"
        },
        "danubedata:index/DatabaseTimeouts:DatabaseTimeouts": {
            "properties": {
                "create": {
                    "type": "string",
                    "description": "Time to wait for database creation.\n"
                },
                "delete": {
                    "type": "string",
                    "description": "Time to wait for database deletion.\n"
                },
                "update": {
                    "type": "string",
                    "description": "Time to wait for database updates.\n"
                }
            },
            "type": "object"
        },
        "danubedata:index/FirewallRule:FirewallRule": {
            "properties": {
                "action": {
                    "type": "string",
                    "description": "Action: `allow` or `deny`.\n"
                },
                "direction": {
                    "type": "string",
                    "description": "Direction: `inbound` or `outbound`.\n"
                },
                "id": {
                    "type": "string",
                    "description": "The firewall ID.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the rule.\n"
                },
                "portRangeEnd": {
                    "type": "integer",
                    "description": "End of port range.\n"
                },
                "portRangeStart": {
                    "type": "integer",
                    "description": "Start of port range.\n"
                },
                "priority": {
                    "type": "integer",
                    "description": "Rule priority (lower = higher priority).\n"
                },
                "protocol": {
                    "type": "string",
                    "description": "Protocol: `tcp`, `udp`, `icmp`, or `all`.\n"
                },
                "sourceIps": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of source IP addresses/CIDRs.\n"
                }
            },
            "type": "object",
            "required": [
                "action",
                "direction",
                "protocol"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "action",
                        "direction",
                        "id",
                        "protocol"
                    ]
                }
            }
        },
        "danubedata:index/ServerlessTimeouts:ServerlessTimeouts": {
            "properties": {
                "create": {
                    "type": "string",
                    "description": "Time to wait for container creation.\n"
                },
                "delete": {
                    "type": "string",
                    "description": "Time to wait for container deletion.\n"
                },
                "update": {
                    "type": "string",
                    "description": "Time to wait for container updates.\n"
                }
            },
            "type": "object"
        },
        "danubedata:index/StorageBucketTimeouts:StorageBucketTimeouts": {
            "properties": {
                "create": {
                    "type": "string",
                    "description": "Time to wait for bucket creation.\n"
                },
                "delete": {
                    "type": "string",
                    "description": "Time to wait for bucket deletion.\n"
                },
                "update": {
                    "type": "string",
                    "description": "Time to wait for bucket updates.\n"
                }
            },
            "type": "object"
        },
        "danubedata:index/VpsSnapshotTimeouts:VpsSnapshotTimeouts": {
            "properties": {
                "create": {
                    "type": "string",
                    "description": "Time to wait for snapshot creation.\n"
                },
                "delete": {
                    "type": "string",
                    "description": "Time to wait for snapshot deletion.\n"
                }
            },
            "type": "object"
        },
        "danubedata:index/VpsTimeouts:VpsTimeouts": {
            "properties": {
                "create": {
                    "type": "string",
                    "description": "Time to wait for VPS creation.\n"
                },
                "delete": {
                    "type": "string",
                    "description": "Time to wait for VPS deletion.\n"
                },
                "update": {
                    "type": "string",
                    "description": "Time to wait for VPS updates.\n"
                }
            },
            "type": "object"
        },
        "danubedata:index/getCacheProvidersProvider:getCacheProvidersProvider": {
            "properties": {
                "defaultPort": {
                    "type": "integer",
                    "description": "Default port number.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Provider description.\n"
                },
                "id": {
                    "type": "integer",
                    "description": "The provider ID.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Provider name (e.g., \"Redis\", \"Valkey\", \"Dragonfly\").\n"
                },
                "type": {
                    "type": "string",
                    "description": "Provider type identifier.\n"
                },
                "version": {
                    "type": "string",
                    "description": "Default version.\n"
                }
            },
            "type": "object",
            "required": [
                "defaultPort",
                "description",
                "id",
                "name",
                "type",
                "version"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "danubedata:index/getCachesInstance:getCachesInstance": {
            "properties": {
                "cacheProvider": {
                    "type": "string",
                    "description": "Cache provider (Redis, Valkey, Dragonfly).\n"
                },
                "cpuCores": {
                    "type": "integer",
                    "description": "Number of CPU cores.\n"
                },
                "createdAt": {
                    "type": "string",
                    "description": "Timestamp when the instance was created.\n"
                },
                "datacenter": {
                    "type": "string",
                    "description": "Datacenter location.\n"
                },
                "endpoint": {
                    "type": "string",
                    "description": "Connection endpoint hostname.\n"
                },
                "id": {
                    "type": "string",
                    "description": "Unique identifier for the cache instance.\n"
                },
                "memorySizeMb": {
                    "type": "integer",
                    "description": "Memory size in MB.\n"
                },
                "monthlyCost": {
                    "type": "number",
                    "description": "Estimated monthly cost.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the cache instance.\n"
                },
                "port": {
                    "type": "integer",
                    "description": "Connection port.\n"
                },
                "resourceProfile": {
                    "type": "string",
                    "description": "Resource profile (predefined CPU/RAM configuration).\n"
                },
                "status": {
                    "type": "string",
                    "description": "Current status (creating, running, stopped, error).\n"
                },
                "version": {
                    "type": "string",
                    "description": "Cache version.\n"
                }
            },
            "type": "object",
            "required": [
                "cacheProvider",
                "cpuCores",
                "createdAt",
                "datacenter",
                "endpoint",
                "id",
                "memorySizeMb",
                "monthlyCost",
                "name",
                "port",
                "resourceProfile",
                "status",
                "version"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "danubedata:index/getDatabaseProvidersProvider:getDatabaseProvidersProvider": {
            "properties": {
                "defaultPort": {
                    "type": "integer",
                    "description": "Default port number.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Provider description.\n"
                },
                "id": {
                    "type": "integer",
                    "description": "The provider ID.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Provider name (e.g., \"MySQL\", \"PostgreSQL\", \"MariaDB\").\n"
                },
                "type": {
                    "type": "string",
                    "description": "Provider type identifier.\n"
                },
                "version": {
                    "type": "string",
                    "description": "Default version.\n"
                }
            },
            "type": "object",
            "required": [
                "defaultPort",
                "description",
                "id",
                "name",
                "type",
                "version"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "danubedata:index/getDatabasesInstance:getDatabasesInstance": {
            "properties": {
                "cpuCores": {
                    "type": "integer",
                    "description": "Number of CPU cores.\n"
                },
                "createdAt": {
                    "type": "string",
                    "description": "Timestamp when the instance was created.\n"
                },
                "databaseName": {
                    "type": "string",
                    "description": "Name of the database.\n"
                },
                "datacenter": {
                    "type": "string",
                    "description": "Datacenter location.\n"
                },
                "endpoint": {
                    "type": "string",
                    "description": "Connection endpoint hostname.\n"
                },
                "engine": {
                    "type": "string",
                    "description": "Database engine (MySQL, PostgreSQL, MariaDB).\n"
                },
                "id": {
                    "type": "string",
                    "description": "Unique identifier for the database instance.\n"
                },
                "memorySizeMb": {
                    "type": "integer",
                    "description": "Memory size in MB.\n"
                },
                "monthlyCost": {
                    "type": "number",
                    "description": "Estimated monthly cost.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the database instance.\n"
                },
                "port": {
                    "type": "integer",
                    "description": "Connection port.\n"
                },
                "resourceProfile": {
                    "type": "string",
                    "description": "Resource profile (predefined CPU/RAM/Storage configuration).\n"
                },
                "status": {
                    "type": "string",
                    "description": "Current status (creating, running, stopped, error).\n"
                },
                "storageSizeGb": {
                    "type": "integer",
                    "description": "Storage size in GB.\n"
                },
                "username": {
                    "type": "string",
                    "description": "Database admin username.\n"
                },
                "version": {
                    "type": "string",
                    "description": "Database version.\n"
                }
            },
            "type": "object",
            "required": [
                "cpuCores",
                "createdAt",
                "databaseName",
                "datacenter",
                "endpoint",
                "engine",
                "id",
                "memorySizeMb",
                "monthlyCost",
                "name",
                "port",
                "resourceProfile",
                "status",
                "storageSizeGb",
                "username",
                "version"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "danubedata:index/getFirewallsFirewall:getFirewallsFirewall": {
            "properties": {
                "createdAt": {
                    "type": "string",
                    "description": "Timestamp when the firewall was created.\n"
                },
                "defaultAction": {
                    "type": "string",
                    "description": "Default action for unmatched traffic (allow or deny).\n"
                },
                "description": {
                    "type": "string",
                    "description": "Description of the firewall.\n"
                },
                "id": {
                    "type": "string",
                    "description": "Unique identifier for the firewall.\n"
                },
                "isDefault": {
                    "type": "boolean",
                    "description": "Whether this is the default firewall.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the firewall.\n"
                },
                "rulesCount": {
                    "type": "integer",
                    "description": "Number of rules in the firewall.\n"
                },
                "status": {
                    "type": "string",
                    "description": "Current status.\n"
                }
            },
            "type": "object",
            "required": [
                "createdAt",
                "defaultAction",
                "description",
                "id",
                "isDefault",
                "name",
                "rulesCount",
                "status"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "danubedata:index/getServerlessContainersContainer:getServerlessContainersContainer": {
            "properties": {
                "createdAt": {
                    "type": "string",
                    "description": "Timestamp when the container was created.\n"
                },
                "deploymentType": {
                    "type": "string",
                    "description": "Deployment type (docker or git).\n"
                },
                "gitBranch": {
                    "type": "string",
                    "description": "Git branch (for git deployment).\n"
                },
                "gitRepository": {
                    "type": "string",
                    "description": "Git repository URL (for git deployment).\n"
                },
                "id": {
                    "type": "string",
                    "description": "Unique identifier for the container.\n"
                },
                "imageUrl": {
                    "type": "string",
                    "description": "Docker image URL (for docker deployment).\n"
                },
                "maxInstances": {
                    "type": "integer",
                    "description": "Maximum number of instances.\n"
                },
                "minInstances": {
                    "type": "integer",
                    "description": "Minimum number of instances (0 = scale to zero).\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the container.\n"
                },
                "port": {
                    "type": "integer",
                    "description": "Container port.\n"
                },
                "status": {
                    "type": "string",
                    "description": "Current status (creating, building, running, error).\n"
                },
                "url": {
                    "type": "string",
                    "description": "Public HTTPS URL for the container.\n"
                }
            },
            "type": "object",
            "required": [
                "createdAt",
                "deploymentType",
                "gitBranch",
                "gitRepository",
                "id",
                "imageUrl",
                "maxInstances",
                "minInstances",
                "name",
                "port",
                "status",
                "url"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "danubedata:index/getSshKeysKey:getSshKeysKey": {
            "properties": {
                "createdAt": {
                    "type": "string",
                    "description": "Creation timestamp.\n"
                },
                "fingerprint": {
                    "type": "string",
                    "description": "SSH key fingerprint.\n"
                },
                "id": {
                    "type": "string",
                    "description": "The SSH key ID.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the key.\n"
                },
                "publicKey": {
                    "type": "string",
                    "description": "The public key content.\n"
                }
            },
            "type": "object",
            "required": [
                "createdAt",
                "fingerprint",
                "id",
                "name",
                "publicKey"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "danubedata:index/getStorageAccessKeysKey:getStorageAccessKeysKey": {
            "properties": {
                "accessKeyId": {
                    "type": "string",
                    "description": "The S3 access key ID for authentication.\n"
                },
                "accessType": {
                    "type": "string",
                    "description": "Access type (full or restricted).\n"
                },
                "createdAt": {
                    "type": "string",
                    "description": "Timestamp when the key was created.\n"
                },
                "expiresAt": {
                    "type": "string",
                    "description": "Expiration timestamp (if set).\n"
                },
                "id": {
                    "type": "string",
                    "description": "Unique identifier for the access key.\n"
                },
                "isExpired": {
                    "type": "boolean",
                    "description": "Whether the key has expired.\n"
                },
                "isPrefixScoped": {
                    "type": "boolean",
                    "description": "Whether the key is scoped to specific bucket prefixes.\n"
                },
                "lastUsedAt": {
                    "type": "string",
                    "description": "Timestamp when the key was last used.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the access key.\n"
                },
                "status": {
                    "type": "string",
                    "description": "Current status (active, revoked).\n"
                }
            },
            "type": "object",
            "required": [
                "accessKeyId",
                "accessType",
                "createdAt",
                "expiresAt",
                "id",
                "isExpired",
                "isPrefixScoped",
                "lastUsedAt",
                "name",
                "status"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "danubedata:index/getStorageBucketsBucket:getStorageBucketsBucket": {
            "properties": {
                "createdAt": {
                    "type": "string",
                    "description": "Timestamp when the bucket was created.\n"
                },
                "displayName": {
                    "type": "string",
                    "description": "Human-readable display name.\n"
                },
                "encryptionEnabled": {
                    "type": "boolean",
                    "description": "Whether encryption is enabled.\n"
                },
                "endpointUrl": {
                    "type": "string",
                    "description": "S3-compatible endpoint URL.\n"
                },
                "id": {
                    "type": "string",
                    "description": "Unique identifier for the bucket.\n"
                },
                "minioBucketName": {
                    "type": "string",
                    "description": "Internal bucket name for S3 operations.\n"
                },
                "monthlyCost": {
                    "type": "number",
                    "description": "Estimated monthly cost.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the bucket.\n"
                },
                "objectCount": {
                    "type": "integer",
                    "description": "Number of objects in the bucket.\n"
                },
                "publicAccess": {
                    "type": "boolean",
                    "description": "Whether public access is enabled.\n"
                },
                "publicUrl": {
                    "type": "string",
                    "description": "Public URL (if public access enabled).\n"
                },
                "region": {
                    "type": "string",
                    "description": "Region where the bucket is located.\n"
                },
                "sizeBytes": {
                    "type": "integer",
                    "description": "Current size in bytes.\n"
                },
                "status": {
                    "type": "string",
                    "description": "Current status.\n"
                },
                "versioningEnabled": {
                    "type": "boolean",
                    "description": "Whether versioning is enabled.\n"
                }
            },
            "type": "object",
            "required": [
                "createdAt",
                "displayName",
                "encryptionEnabled",
                "endpointUrl",
                "id",
                "minioBucketName",
                "monthlyCost",
                "name",
                "objectCount",
                "publicAccess",
                "publicUrl",
                "region",
                "sizeBytes",
                "status",
                "versioningEnabled"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "danubedata:index/getVpsImagesImage:getVpsImagesImage": {
            "properties": {
                "defaultUser": {
                    "type": "string",
                    "description": "Default SSH user for this image.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Image description.\n"
                },
                "distro": {
                    "type": "string",
                    "description": "Distribution name (e.g., `ubuntu`, `debian`, `almalinux`).\n"
                },
                "family": {
                    "type": "string",
                    "description": "Image family (if applicable).\n"
                },
                "id": {
                    "type": "string",
                    "description": "The image ID.\n"
                },
                "image": {
                    "type": "string",
                    "description": "Image identifier used when creating VPS.\n"
                },
                "label": {
                    "type": "string",
                    "description": "Human-readable label.\n"
                },
                "version": {
                    "type": "string",
                    "description": "Distribution version.\n"
                }
            },
            "type": "object",
            "required": [
                "defaultUser",
                "description",
                "distro",
                "family",
                "id",
                "image",
                "label",
                "version"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "danubedata:index/getVpsSnapshotsSnapshot:getVpsSnapshotsSnapshot": {
            "properties": {
                "createdAt": {
                    "type": "string",
                    "description": "Timestamp when the snapshot was created.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Description of the snapshot.\n"
                },
                "id": {
                    "type": "string",
                    "description": "Unique identifier for the snapshot.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the snapshot.\n"
                },
                "sizeGb": {
                    "type": "number",
                    "description": "Size of the snapshot in GB.\n"
                },
                "status": {
                    "type": "string",
                    "description": "Current status (creating, ready, error).\n"
                },
                "vpsInstanceId": {
                    "type": "string",
                    "description": "ID of the VPS instance this snapshot belongs to.\n"
                }
            },
            "type": "object",
            "required": [
                "createdAt",
                "description",
                "id",
                "name",
                "sizeGb",
                "status",
                "vpsInstanceId"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "danubedata:index/getVpssInstance:getVpssInstance": {
            "properties": {
                "cpuAllocationType": {
                    "type": "string",
                    "description": "CPU allocation type (shared or dedicated).\n"
                },
                "cpuCores": {
                    "type": "integer",
                    "description": "Number of CPU cores.\n"
                },
                "createdAt": {
                    "type": "string",
                    "description": "Timestamp when the instance was created.\n"
                },
                "datacenter": {
                    "type": "string",
                    "description": "Datacenter location.\n"
                },
                "id": {
                    "type": "string",
                    "description": "Unique identifier for the VPS instance.\n"
                },
                "image": {
                    "type": "string",
                    "description": "Operating system image.\n"
                },
                "ipv6Address": {
                    "type": "string",
                    "description": "IPv6 address (if enabled).\n"
                },
                "memorySizeGb": {
                    "type": "integer",
                    "description": "Memory size in GB.\n"
                },
                "monthlyCost": {
                    "type": "number",
                    "description": "Estimated monthly cost.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the VPS instance.\n"
                },
                "privateIp": {
                    "type": "string",
                    "description": "Private IP address (if assigned).\n"
                },
                "publicIp": {
                    "type": "string",
                    "description": "Public IPv4 address (if assigned).\n"
                },
                "resourceProfile": {
                    "type": "string",
                    "description": "Resource profile (predefined CPU/RAM/Storage configuration).\n"
                },
                "status": {
                    "type": "string",
                    "description": "Current status (creating, running, stopped, error).\n"
                },
                "storageSizeGb": {
                    "type": "integer",
                    "description": "Storage size in GB.\n"
                }
            },
            "type": "object",
            "required": [
                "cpuAllocationType",
                "cpuCores",
                "createdAt",
                "datacenter",
                "id",
                "image",
                "ipv6Address",
                "memorySizeGb",
                "monthlyCost",
                "name",
                "privateIp",
                "publicIp",
                "resourceProfile",
                "status",
                "storageSizeGb"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        }
    },
    "provider": {
        "description": "The provider type for the danubedata package. By default, resources use package-wide configuration\nsettings, however an explicit `Provider` instance may be created and passed during resource\nconstruction to achieve fine-grained programmatic control over provider settings. See the\n[documentation](https://www.pulumi.com/docs/reference/programming-model/#providers) for more information.\n",
        "properties": {
            "apiToken": {
                "type": "string",
                "description": "API token for DanubeData authentication. Can also be set via DANUBEDATA_API_TOKEN environment variable.\n",
                "secret": true
            },
            "baseUrl": {
                "type": "string",
                "description": "Base URL for the DanubeData API. Defaults to https://danubedata.ro/api/v1. Can also be set via DANUBEDATA_BASE_URL\nenvironment variable.\n"
            }
        },
        "inputProperties": {
            "apiToken": {
                "type": "string",
                "description": "API token for DanubeData authentication. Can also be set via DANUBEDATA_API_TOKEN environment variable.\n",
                "defaultInfo": {
                    "environment": [
                        "DANUBEDATA_API_TOKEN"
                    ]
                },
                "secret": true
            },
            "baseUrl": {
                "type": "string",
                "description": "Base URL for the DanubeData API. Defaults to https://danubedata.ro/api/v1. Can also be set via DANUBEDATA_BASE_URL\nenvironment variable.\n",
                "default": "https://danubedata.ro/api/v1",
                "defaultInfo": {
                    "environment": [
                        "DANUBEDATA_BASE_URL"
                    ]
                }
            }
        }
    },
    "resources": {
        "danubedata:index/cache:Cache": {
            "description": "## # danubedata.Cache\n\nManages an in-memory cache instance (Redis, Valkey, or Dragonfly).\n\n## Example Usage\n\n### Redis Cache\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as danubedata from \"@danubedata/pulumi\";\n\nconst redis = new danubedata.Cache(\"redis\", {\n    cacheProvider: \"redis\",\n    memorySizeMb: 512,\n    cpuCores: 1,\n    datacenter: \"fsn1\",\n    version: \"7.2\",\n});\nexport const redisEndpoint = redis.endpoint;\n```\n```python\nimport pulumi\nimport pulumi_danubedata as danubedata\n\nredis = danubedata.Cache(\"redis\",\n    cache_provider=\"redis\",\n    memory_size_mb=512,\n    cpu_cores=1,\n    datacenter=\"fsn1\",\n    version=\"7.2\")\npulumi.export(\"redisEndpoint\", redis.endpoint)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing DanubeData = DanubeData.DanubeData;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var redis = new DanubeData.Cache(\"redis\", new()\n    {\n        CacheProvider = \"redis\",\n        MemorySizeMb = 512,\n        CpuCores = 1,\n        Datacenter = \"fsn1\",\n        Version = \"7.2\",\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"redisEndpoint\"] = redis.Endpoint,\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/AdrianSilaghi/pulumi-danubedata/sdk/go/danubedata\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tredis, err := danubedata.NewCache(ctx, \"redis\", \u0026danubedata.CacheArgs{\n\t\t\tCacheProvider: pulumi.String(\"redis\"),\n\t\t\tMemorySizeMb:  pulumi.Int(512),\n\t\t\tCpuCores:      pulumi.Int(1),\n\t\t\tDatacenter:    pulumi.String(\"fsn1\"),\n\t\t\tVersion:       pulumi.String(\"7.2\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"redisEndpoint\", redis.Endpoint)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.danubedata.Cache;\nimport com.pulumi.danubedata.CacheArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var redis = new Cache(\"redis\", CacheArgs.builder()\n            .cacheProvider(\"redis\")\n            .memorySizeMb(512)\n            .cpuCores(1)\n            .datacenter(\"fsn1\")\n            .version(\"7.2\")\n            .build());\n\n        ctx.export(\"redisEndpoint\", redis.endpoint());\n    }\n}\n```\n```yaml\nresources:\n  redis:\n    type: danubedata:Cache\n    properties:\n      cacheProvider: redis\n      memorySizeMb: 512\n      cpuCores: 1\n      datacenter: fsn1\n      version: '7.2'\noutputs:\n  redisEndpoint: ${redis.endpoint}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Valkey Cache (Redis Fork)\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as danubedata from \"@danubedata/pulumi\";\n\nconst valkey = new danubedata.Cache(\"valkey\", {\n    cacheProvider: \"valkey\",\n    cpuCores: 2,\n    datacenter: \"fsn1\",\n    memorySizeMb: 1024,\n});\n```\n```python\nimport pulumi\nimport pulumi_danubedata as danubedata\n\nvalkey = danubedata.Cache(\"valkey\",\n    cache_provider=\"valkey\",\n    cpu_cores=2,\n    datacenter=\"fsn1\",\n    memory_size_mb=1024)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing DanubeData = DanubeData.DanubeData;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var valkey = new DanubeData.Cache(\"valkey\", new()\n    {\n        CacheProvider = \"valkey\",\n        CpuCores = 2,\n        Datacenter = \"fsn1\",\n        MemorySizeMb = 1024,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/AdrianSilaghi/pulumi-danubedata/sdk/go/danubedata\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := danubedata.NewCache(ctx, \"valkey\", \u0026danubedata.CacheArgs{\n\t\t\tCacheProvider: pulumi.String(\"valkey\"),\n\t\t\tCpuCores:      pulumi.Int(2),\n\t\t\tDatacenter:    pulumi.String(\"fsn1\"),\n\t\t\tMemorySizeMb:  pulumi.Int(1024),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.danubedata.Cache;\nimport com.pulumi.danubedata.CacheArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var valkey = new Cache(\"valkey\", CacheArgs.builder()\n            .cacheProvider(\"valkey\")\n            .cpuCores(2)\n            .datacenter(\"fsn1\")\n            .memorySizeMb(1024)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  valkey:\n    type: danubedata:Cache\n    properties:\n      cacheProvider: valkey\n      cpuCores: 2\n      datacenter: fsn1\n      memorySizeMb: 1024\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Dragonfly Cache (High Performance)\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as danubedata from \"@danubedata/pulumi\";\n\nconst dragonfly = new danubedata.Cache(\"dragonfly\", {\n    cacheProvider: \"dragonfly\",\n    cpuCores: 4,\n    datacenter: \"fsn1\",\n    memorySizeMb: 2048,\n});\n```\n```python\nimport pulumi\nimport pulumi_danubedata as danubedata\n\ndragonfly = danubedata.Cache(\"dragonfly\",\n    cache_provider=\"dragonfly\",\n    cpu_cores=4,\n    datacenter=\"fsn1\",\n    memory_size_mb=2048)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing DanubeData = DanubeData.DanubeData;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var dragonfly = new DanubeData.Cache(\"dragonfly\", new()\n    {\n        CacheProvider = \"dragonfly\",\n        CpuCores = 4,\n        Datacenter = \"fsn1\",\n        MemorySizeMb = 2048,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/AdrianSilaghi/pulumi-danubedata/sdk/go/danubedata\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := danubedata.NewCache(ctx, \"dragonfly\", \u0026danubedata.CacheArgs{\n\t\t\tCacheProvider: pulumi.String(\"dragonfly\"),\n\t\t\tCpuCores:      pulumi.Int(4),\n\t\t\tDatacenter:    pulumi.String(\"fsn1\"),\n\t\t\tMemorySizeMb:  pulumi.Int(2048),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.danubedata.Cache;\nimport com.pulumi.danubedata.CacheArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var dragonfly = new Cache(\"dragonfly\", CacheArgs.builder()\n            .cacheProvider(\"dragonfly\")\n            .cpuCores(4)\n            .datacenter(\"fsn1\")\n            .memorySizeMb(2048)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  dragonfly:\n    type: danubedata:Cache\n    properties:\n      cacheProvider: dragonfly\n      cpuCores: 4\n      datacenter: fsn1\n      memorySizeMb: 2048\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Using Resource Profile\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as danubedata from \"@danubedata/pulumi\";\n\nconst standard = new danubedata.Cache(\"standard\", {\n    resourceProfile: \"cache-medium\",\n    datacenter: \"fsn1\",\n}, {\n    provider: \"redis\",\n});\n```\n```python\nimport pulumi\nimport pulumi_danubedata as danubedata\n\nstandard = danubedata.Cache(\"standard\",\n    resource_profile=\"cache-medium\",\n    datacenter=\"fsn1\",\n    opts = pulumi.ResourceOptions(provider=\"redis\"))\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing DanubeData = DanubeData.DanubeData;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var standard = new DanubeData.Cache(\"standard\", new()\n    {\n        ResourceProfile = \"cache-medium\",\n        Datacenter = \"fsn1\",\n    }, new CustomResourceOptions\n    {\n        Provider = \"redis\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/AdrianSilaghi/pulumi-danubedata/sdk/go/danubedata\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := danubedata.NewCache(ctx, \"standard\", \u0026danubedata.CacheArgs{\n\t\t\tResourceProfile: pulumi.String(\"cache-medium\"),\n\t\t\tDatacenter:      pulumi.String(\"fsn1\"),\n\t\t}, pulumi.Provider(\"redis\"))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.danubedata.Cache;\nimport com.pulumi.danubedata.CacheArgs;\nimport com.pulumi.resources.CustomResourceOptions;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var standard = new Cache(\"standard\", CacheArgs.builder()\n            .resourceProfile(\"cache-medium\")\n            .datacenter(\"fsn1\")\n            .build(), CustomResourceOptions.builder()\n                .provider(\"redis\")\n                .build());\n\n    }\n}\n```\n```yaml\nresources:\n  standard:\n    type: danubedata:Cache\n    properties:\n      resourceProfile: cache-medium\n      datacenter: fsn1\n    options:\n      provider: redis\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nCache instances can be imported using their ID:\n\nbash\n\n```sh\n$ pulumi import danubedata:index/cache:Cache example cache-abc123\n```\n\n",
            "properties": {
                "cacheProvider": {
                    "type": "string",
                    "description": "Cache provider type (redis, valkey, dragonfly).\n"
                },
                "cpuCores": {
                    "type": "integer",
                    "description": "Number of CPU cores. If not specified, determined by resource_profile.\n"
                },
                "createdAt": {
                    "type": "string",
                    "description": "Creation timestamp.\n"
                },
                "datacenter": {
                    "type": "string",
                    "description": "Datacenter location (ash, fsn1, nbg1, hel1).\n"
                },
                "deployedAt": {
                    "type": "string",
                    "description": "Deployment timestamp.\n"
                },
                "endpoint": {
                    "type": "string",
                    "description": "Connection endpoint hostname.\n"
                },
                "memorySizeMb": {
                    "type": "integer",
                    "description": "Memory size in MB. If not specified, determined by resource_profile.\n"
                },
                "monthlyCost": {
                    "type": "number",
                    "description": "Estimated monthly cost.\n"
                },
                "monthlyCostCents": {
                    "type": "integer",
                    "description": "Monthly cost in cents.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the cache instance.\n"
                },
                "parameterGroupId": {
                    "type": "string",
                    "description": "ID of the parameter group to use for custom configuration.\n"
                },
                "port": {
                    "type": "integer",
                    "description": "Connection port.\n"
                },
                "resourceProfile": {
                    "type": "string",
                    "description": "Resource profile for the cache (micro, small, medium, large).\n"
                },
                "status": {
                    "type": "string",
                    "description": "Current status.\n"
                },
                "timeouts": {
                    "$ref": "#/types/danubedata:index/CacheTimeouts:CacheTimeouts"
                },
                "updatedAt": {
                    "type": "string",
                    "description": "Timestamp when the cache instance was last updated.\n"
                },
                "version": {
                    "type": "string",
                    "description": "Version of the cache software.\n"
                }
            },
            "required": [
                "cacheProvider",
                "cpuCores",
                "createdAt",
                "datacenter",
                "deployedAt",
                "endpoint",
                "memorySizeMb",
                "monthlyCost",
                "monthlyCostCents",
                "name",
                "port",
                "resourceProfile",
                "status",
                "updatedAt",
                "version"
            ],
            "inputProperties": {
                "cacheProvider": {
                    "type": "string",
                    "description": "Cache provider type (redis, valkey, dragonfly).\n"
                },
                "cpuCores": {
                    "type": "integer",
                    "description": "Number of CPU cores. If not specified, determined by resource_profile.\n"
                },
                "datacenter": {
                    "type": "string",
                    "description": "Datacenter location (ash, fsn1, nbg1, hel1).\n"
                },
                "memorySizeMb": {
                    "type": "integer",
                    "description": "Memory size in MB. If not specified, determined by resource_profile.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the cache instance.\n"
                },
                "parameterGroupId": {
                    "type": "string",
                    "description": "ID of the parameter group to use for custom configuration.\n"
                },
                "resourceProfile": {
                    "type": "string",
                    "description": "Resource profile for the cache (micro, small, medium, large).\n"
                },
                "timeouts": {
                    "$ref": "#/types/danubedata:index/CacheTimeouts:CacheTimeouts"
                },
                "version": {
                    "type": "string",
                    "description": "Version of the cache software.\n"
                }
            },
            "requiredInputs": [
                "cacheProvider",
                "datacenter",
                "resourceProfile"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Cache resources.\n",
                "properties": {
                    "cacheProvider": {
                        "type": "string",
                        "description": "Cache provider type (redis, valkey, dragonfly).\n"
                    },
                    "cpuCores": {
                        "type": "integer",
                        "description": "Number of CPU cores. If not specified, determined by resource_profile.\n"
                    },
                    "createdAt": {
                        "type": "string",
                        "description": "Creation timestamp.\n"
                    },
                    "datacenter": {
                        "type": "string",
                        "description": "Datacenter location (ash, fsn1, nbg1, hel1).\n"
                    },
                    "deployedAt": {
                        "type": "string",
                        "description": "Deployment timestamp.\n"
                    },
                    "endpoint": {
                        "type": "string",
                        "description": "Connection endpoint hostname.\n"
                    },
                    "memorySizeMb": {
                        "type": "integer",
                        "description": "Memory size in MB. If not specified, determined by resource_profile.\n"
                    },
                    "monthlyCost": {
                        "type": "number",
                        "description": "Estimated monthly cost.\n"
                    },
                    "monthlyCostCents": {
                        "type": "integer",
                        "description": "Monthly cost in cents.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the cache instance.\n"
                    },
                    "parameterGroupId": {
                        "type": "string",
                        "description": "ID of the parameter group to use for custom configuration.\n"
                    },
                    "port": {
                        "type": "integer",
                        "description": "Connection port.\n"
                    },
                    "resourceProfile": {
                        "type": "string",
                        "description": "Resource profile for the cache (micro, small, medium, large).\n"
                    },
                    "status": {
                        "type": "string",
                        "description": "Current status.\n"
                    },
                    "timeouts": {
                        "$ref": "#/types/danubedata:index/CacheTimeouts:CacheTimeouts"
                    },
                    "updatedAt": {
                        "type": "string",
                        "description": "Timestamp when the cache instance was last updated.\n"
                    },
                    "version": {
                        "type": "string",
                        "description": "Version of the cache software.\n"
                    }
                },
                "type": "object"
            }
        },
        "danubedata:index/database:Database": {
            "description": "## # danubedata.Database\n\nManages a managed database instance (MySQL, PostgreSQL, or MariaDB).\n\n## Example Usage\n\n### MySQL Database\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```yaml\nresources:\n  mysql:\n    type: danubedata:Database\n    properties:\n      databaseName: app_production\n      engine: mysql\n      version: '8.0'\n      storageSizeGb: 20\n      memorySizeMb: 2048\n      cpuCores: 2\n      datacenter: fsn1\noutputs:\n  mysqlEndpoint: ${mysql.endpoint}\n  mysqlPort: ${mysql.port}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### PostgreSQL Database\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```yaml\nresources:\n  postgres:\n    type: danubedata:Database\n    properties:\n      cpuCores: 4\n      databaseName: analytics\n      datacenter: fsn1\n      engine: postgresql\n      memorySizeMb: 4096\n      storageSizeGb: 50\n      version: '16'\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### MariaDB Database\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```yaml\nresources:\n  mariadb:\n    type: danubedata:Database\n    properties:\n      cpuCores: 2\n      databaseName: legacy_app\n      datacenter: fsn1\n      engine: mariadb\n      memorySizeMb: 2048\n      storageSizeGb: 20\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Using Resource Profile\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as danubedata from \"@danubedata/pulumi\";\n\nconst standard = new danubedata.Database(\"standard\", {\n    datacenter: \"fsn1\",\n    engine: \"mysql\",\n    resourceProfile: \"db-medium\",\n});\n```\n```python\nimport pulumi\nimport pulumi_danubedata as danubedata\n\nstandard = danubedata.Database(\"standard\",\n    datacenter=\"fsn1\",\n    engine=\"mysql\",\n    resource_profile=\"db-medium\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing DanubeData = DanubeData.DanubeData;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var standard = new DanubeData.Database(\"standard\", new()\n    {\n        Datacenter = \"fsn1\",\n        Engine = \"mysql\",\n        ResourceProfile = \"db-medium\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/AdrianSilaghi/pulumi-danubedata/sdk/go/danubedata\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := danubedata.NewDatabase(ctx, \"standard\", \u0026danubedata.DatabaseArgs{\n\t\t\tDatacenter:      pulumi.String(\"fsn1\"),\n\t\t\tEngine:          pulumi.String(\"mysql\"),\n\t\t\tResourceProfile: pulumi.String(\"db-medium\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.danubedata.Database;\nimport com.pulumi.danubedata.DatabaseArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var standard = new Database(\"standard\", DatabaseArgs.builder()\n            .datacenter(\"fsn1\")\n            .engine(\"mysql\")\n            .resourceProfile(\"db-medium\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  standard:\n    type: danubedata:Database\n    properties:\n      datacenter: fsn1\n      engine: mysql\n      resourceProfile: db-medium\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Notes\n\n- Database credentials are managed separately and can be retrieved via the API.\n- Storage size can only be increased, not decreased.\n- Version upgrades may cause brief downtime.\n\n## Import\n\nDatabase instances can be imported using their ID:\n\nbash\n\n```sh\n$ pulumi import danubedata:index/database:Database example db-abc123\n```\n\n",
            "properties": {
                "cpuCores": {
                    "type": "integer",
                    "description": "Number of CPU cores. Derived from resource_profile.\n"
                },
                "createdAt": {
                    "type": "string",
                    "description": "Creation timestamp.\n"
                },
                "databaseName": {
                    "type": "string",
                    "description": "Name of the initial database to create. Must start with a letter and contain only letters, numbers, and underscores.\n"
                },
                "datacenter": {
                    "type": "string",
                    "description": "Datacenter location (fsn1, nbg1, hel1).\n"
                },
                "deployedAt": {
                    "type": "string",
                    "description": "Deployment timestamp.\n"
                },
                "endpoint": {
                    "type": "string",
                    "description": "Connection endpoint hostname.\n"
                },
                "engine": {
                    "type": "string",
                    "description": "Database engine (mysql, postgresql, mariadb).\n"
                },
                "memorySizeMb": {
                    "type": "integer",
                    "description": "Memory size in MB. Derived from resource_profile.\n"
                },
                "monthlyCost": {
                    "type": "number",
                    "description": "Estimated monthly cost.\n"
                },
                "monthlyCostCents": {
                    "type": "integer",
                    "description": "Monthly cost in cents.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the database instance. Must be lowercase alphanumeric with hyphens (DNS compatible).\n"
                },
                "parameterGroupId": {
                    "type": "string",
                    "description": "ID of the parameter group to use for custom configuration.\n"
                },
                "port": {
                    "type": "integer",
                    "description": "Connection port.\n"
                },
                "resourceProfile": {
                    "type": "string",
                    "description": "Resource profile for the database (small, medium, large).\n"
                },
                "status": {
                    "type": "string",
                    "description": "Current status.\n"
                },
                "storageSizeGb": {
                    "type": "integer",
                    "description": "Storage size in GB. Derived from resource_profile.\n"
                },
                "timeouts": {
                    "$ref": "#/types/danubedata:index/DatabaseTimeouts:DatabaseTimeouts"
                },
                "updatedAt": {
                    "type": "string",
                    "description": "Timestamp when the database instance was last updated.\n"
                },
                "username": {
                    "type": "string",
                    "description": "Database admin username.\n"
                },
                "version": {
                    "type": "string",
                    "description": "Version of the database software.\n"
                }
            },
            "required": [
                "cpuCores",
                "createdAt",
                "datacenter",
                "deployedAt",
                "endpoint",
                "engine",
                "memorySizeMb",
                "monthlyCost",
                "monthlyCostCents",
                "name",
                "port",
                "resourceProfile",
                "status",
                "storageSizeGb",
                "updatedAt",
                "username",
                "version"
            ],
            "inputProperties": {
                "databaseName": {
                    "type": "string",
                    "description": "Name of the initial database to create. Must start with a letter and contain only letters, numbers, and underscores.\n"
                },
                "datacenter": {
                    "type": "string",
                    "description": "Datacenter location (fsn1, nbg1, hel1).\n"
                },
                "engine": {
                    "type": "string",
                    "description": "Database engine (mysql, postgresql, mariadb).\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the database instance. Must be lowercase alphanumeric with hyphens (DNS compatible).\n"
                },
                "parameterGroupId": {
                    "type": "string",
                    "description": "ID of the parameter group to use for custom configuration.\n"
                },
                "resourceProfile": {
                    "type": "string",
                    "description": "Resource profile for the database (small, medium, large).\n"
                },
                "timeouts": {
                    "$ref": "#/types/danubedata:index/DatabaseTimeouts:DatabaseTimeouts"
                },
                "version": {
                    "type": "string",
                    "description": "Version of the database software.\n"
                }
            },
            "requiredInputs": [
                "datacenter",
                "engine",
                "resourceProfile"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Database resources.\n",
                "properties": {
                    "cpuCores": {
                        "type": "integer",
                        "description": "Number of CPU cores. Derived from resource_profile.\n"
                    },
                    "createdAt": {
                        "type": "string",
                        "description": "Creation timestamp.\n"
                    },
                    "databaseName": {
                        "type": "string",
                        "description": "Name of the initial database to create. Must start with a letter and contain only letters, numbers, and underscores.\n"
                    },
                    "datacenter": {
                        "type": "string",
                        "description": "Datacenter location (fsn1, nbg1, hel1).\n"
                    },
                    "deployedAt": {
                        "type": "string",
                        "description": "Deployment timestamp.\n"
                    },
                    "endpoint": {
                        "type": "string",
                        "description": "Connection endpoint hostname.\n"
                    },
                    "engine": {
                        "type": "string",
                        "description": "Database engine (mysql, postgresql, mariadb).\n"
                    },
                    "memorySizeMb": {
                        "type": "integer",
                        "description": "Memory size in MB. Derived from resource_profile.\n"
                    },
                    "monthlyCost": {
                        "type": "number",
                        "description": "Estimated monthly cost.\n"
                    },
                    "monthlyCostCents": {
                        "type": "integer",
                        "description": "Monthly cost in cents.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the database instance. Must be lowercase alphanumeric with hyphens (DNS compatible).\n"
                    },
                    "parameterGroupId": {
                        "type": "string",
                        "description": "ID of the parameter group to use for custom configuration.\n"
                    },
                    "port": {
                        "type": "integer",
                        "description": "Connection port.\n"
                    },
                    "resourceProfile": {
                        "type": "string",
                        "description": "Resource profile for the database (small, medium, large).\n"
                    },
                    "status": {
                        "type": "string",
                        "description": "Current status.\n"
                    },
                    "storageSizeGb": {
                        "type": "integer",
                        "description": "Storage size in GB. Derived from resource_profile.\n"
                    },
                    "timeouts": {
                        "$ref": "#/types/danubedata:index/DatabaseTimeouts:DatabaseTimeouts"
                    },
                    "updatedAt": {
                        "type": "string",
                        "description": "Timestamp when the database instance was last updated.\n"
                    },
                    "username": {
                        "type": "string",
                        "description": "Database admin username.\n"
                    },
                    "version": {
                        "type": "string",
                        "description": "Version of the database software.\n"
                    }
                },
                "type": "object"
            }
        },
        "danubedata:index/firewall:Firewall": {
            "description": "## # danubedata.Firewall\n\nManages a firewall with rules for network traffic control.\n\n## Example Usage\n\n### Basic Firewall\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.danubedata.Firewall;\nimport com.pulumi.danubedata.FirewallArgs;\nimport com.pulumi.danubedata.inputs.FirewallRuleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var web = new Firewall(\"web\", FirewallArgs.builder()\n            .defaultAction(\"deny\")\n            .description(\"Allow HTTP/HTTPS and SSH\")\n            .rules(            \n                FirewallRuleArgs.builder()\n                    .action(\"allow\")\n                    .direction(\"inbound\")\n                    .name(\"Allow SSH\")\n                    .port_range_end(22)\n                    .port_range_start(22)\n                    .priority(100)\n                    .protocol(\"tcp\")\n                    .source_ips(\"0.0.0.0/0\")\n                    .build(),\n                FirewallRuleArgs.builder()\n                    .action(\"allow\")\n                    .direction(\"inbound\")\n                    .name(\"Allow HTTP\")\n                    .port_range_end(80)\n                    .port_range_start(80)\n                    .priority(200)\n                    .protocol(\"tcp\")\n                    .source_ips(\"0.0.0.0/0\")\n                    .build(),\n                FirewallRuleArgs.builder()\n                    .action(\"allow\")\n                    .direction(\"inbound\")\n                    .name(\"Allow HTTPS\")\n                    .port_range_end(443)\n                    .port_range_start(443)\n                    .priority(300)\n                    .protocol(\"tcp\")\n                    .source_ips(\"0.0.0.0/0\")\n                    .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  web:\n    type: danubedata:Firewall\n    properties:\n      defaultAction: deny\n      description: Allow HTTP/HTTPS and SSH\n      rules:\n        - action: allow\n          direction: inbound\n          name: Allow SSH\n          port_range_end: 22\n          port_range_start: 22\n          priority: 100\n          protocol: tcp\n          source_ips:\n            - 0.0.0.0/0\n        - action: allow\n          direction: inbound\n          name: Allow HTTP\n          port_range_end: 80\n          port_range_start: 80\n          priority: 200\n          protocol: tcp\n          source_ips:\n            - 0.0.0.0/0\n        - action: allow\n          direction: inbound\n          name: Allow HTTPS\n          port_range_end: 443\n          port_range_start: 443\n          priority: 300\n          protocol: tcp\n          source_ips:\n            - 0.0.0.0/0\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Firewall with IP Restrictions\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.danubedata.Firewall;\nimport com.pulumi.danubedata.FirewallArgs;\nimport com.pulumi.danubedata.inputs.FirewallRuleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var admin = new Firewall(\"admin\", FirewallArgs.builder()\n            .defaultAction(\"deny\")\n            .description(\"Restricted admin access\")\n            .rules(            \n                FirewallRuleArgs.builder()\n                    .action(\"allow\")\n                    .direction(\"inbound\")\n                    .name(\"Allow SSH from office\")\n                    .port_range_end(22)\n                    .port_range_start(22)\n                    .priority(100)\n                    .protocol(\"tcp\")\n                    .source_ips(                    \n                        \"203.0.113.0/24\",\n                        \"198.51.100.0/24\")\n                    .build(),\n                FirewallRuleArgs.builder()\n                    .action(\"allow\")\n                    .direction(\"outbound\")\n                    .name(\"Allow all outbound\")\n                    .priority(1000)\n                    .protocol(\"all\")\n                    .source_ips(\"0.0.0.0/0\")\n                    .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  admin:\n    type: danubedata:Firewall\n    properties:\n      defaultAction: deny\n      description: Restricted admin access\n      rules:\n        - action: allow\n          direction: inbound\n          name: Allow SSH from office\n          port_range_end: 22\n          port_range_start: 22\n          priority: 100\n          protocol: tcp\n          source_ips:\n            - 203.0.113.0/24\n            - 198.51.100.0/24\n        - action: allow\n          direction: outbound\n          name: Allow all outbound\n          priority: 1000\n          protocol: all\n          source_ips:\n            - 0.0.0.0/0\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nFirewalls can be imported using their ID:\n\nbash\n\n```sh\n$ pulumi import danubedata:index/firewall:Firewall example fw-abc123\n```\n\n",
            "properties": {
                "createdAt": {
                    "type": "string",
                    "description": "Creation timestamp.\n"
                },
                "defaultAction": {
                    "type": "string",
                    "description": "Default action for traffic not matching any rule: 'drop' or 'accept'.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Description of the firewall.\n"
                },
                "isDefault": {
                    "type": "boolean",
                    "description": "Whether this is the default firewall for the team.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the firewall.\n"
                },
                "rules": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/danubedata:index/FirewallRule:FirewallRule"
                    },
                    "description": "List of firewall rules.\n"
                },
                "status": {
                    "type": "string",
                    "description": "Current status of the firewall.\n"
                },
                "updatedAt": {
                    "type": "string",
                    "description": "Timestamp when the firewall was last updated.\n"
                }
            },
            "required": [
                "createdAt",
                "defaultAction",
                "isDefault",
                "name",
                "status",
                "updatedAt"
            ],
            "inputProperties": {
                "defaultAction": {
                    "type": "string",
                    "description": "Default action for traffic not matching any rule: 'drop' or 'accept'.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Description of the firewall.\n"
                },
                "isDefault": {
                    "type": "boolean",
                    "description": "Whether this is the default firewall for the team.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the firewall.\n"
                },
                "rules": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/danubedata:index/FirewallRule:FirewallRule"
                    },
                    "description": "List of firewall rules.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Firewall resources.\n",
                "properties": {
                    "createdAt": {
                        "type": "string",
                        "description": "Creation timestamp.\n"
                    },
                    "defaultAction": {
                        "type": "string",
                        "description": "Default action for traffic not matching any rule: 'drop' or 'accept'.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "Description of the firewall.\n"
                    },
                    "isDefault": {
                        "type": "boolean",
                        "description": "Whether this is the default firewall for the team.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the firewall.\n"
                    },
                    "rules": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/danubedata:index/FirewallRule:FirewallRule"
                        },
                        "description": "List of firewall rules.\n"
                    },
                    "status": {
                        "type": "string",
                        "description": "Current status of the firewall.\n"
                    },
                    "updatedAt": {
                        "type": "string",
                        "description": "Timestamp when the firewall was last updated.\n"
                    }
                },
                "type": "object"
            }
        },
        "danubedata:index/serverless:Serverless": {
            "description": "## # danubedata.Serverless\n\nManages a serverless container with automatic scaling and scale-to-zero support.\n\n## Example Usage\n\n### Docker Image Deployment\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as danubedata from \"@danubedata/pulumi\";\n\nconst nginx = new danubedata.Serverless(\"nginx\", {\n    deploymentType: \"docker\",\n    imageUrl: \"nginx:latest\",\n    port: 80,\n    minInstances: 0,\n    maxInstances: 10,\n});\nexport const appUrl = nginx.url;\n```\n```python\nimport pulumi\nimport pulumi_danubedata as danubedata\n\nnginx = danubedata.Serverless(\"nginx\",\n    deployment_type=\"docker\",\n    image_url=\"nginx:latest\",\n    port=80,\n    min_instances=0,\n    max_instances=10)\npulumi.export(\"appUrl\", nginx.url)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing DanubeData = DanubeData.DanubeData;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var nginx = new DanubeData.Serverless(\"nginx\", new()\n    {\n        DeploymentType = \"docker\",\n        ImageUrl = \"nginx:latest\",\n        Port = 80,\n        MinInstances = 0,\n        MaxInstances = 10,\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"appUrl\"] = nginx.Url,\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/AdrianSilaghi/pulumi-danubedata/sdk/go/danubedata\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tnginx, err := danubedata.NewServerless(ctx, \"nginx\", \u0026danubedata.ServerlessArgs{\n\t\t\tDeploymentType: pulumi.String(\"docker\"),\n\t\t\tImageUrl:       pulumi.String(\"nginx:latest\"),\n\t\t\tPort:           pulumi.Int(80),\n\t\t\tMinInstances:   pulumi.Int(0),\n\t\t\tMaxInstances:   pulumi.Int(10),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"appUrl\", nginx.Url)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.danubedata.Serverless;\nimport com.pulumi.danubedata.ServerlessArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var nginx = new Serverless(\"nginx\", ServerlessArgs.builder()\n            .deploymentType(\"docker\")\n            .imageUrl(\"nginx:latest\")\n            .port(80)\n            .minInstances(0)\n            .maxInstances(10)\n            .build());\n\n        ctx.export(\"appUrl\", nginx.url());\n    }\n}\n```\n```yaml\nresources:\n  nginx:\n    type: danubedata:Serverless\n    properties:\n      deploymentType: docker\n      imageUrl: nginx:latest\n      port: 80\n      minInstances: 0\n      maxInstances: 10\noutputs:\n  appUrl: ${nginx.url}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Git Repository Deployment\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as danubedata from \"@danubedata/pulumi\";\n\nconst app = new danubedata.Serverless(\"app\", {\n    deploymentType: \"git\",\n    environmentVariables: {\n        LOG_LEVEL: \"info\",\n        NODE_ENV: \"production\",\n    },\n    gitBranch: \"main\",\n    gitRepository: \"https://github.com/user/my-app\",\n    maxInstances: 5,\n    minInstances: 1,\n    port: 8080,\n});\n```\n```python\nimport pulumi\nimport pulumi_danubedata as danubedata\n\napp = danubedata.Serverless(\"app\",\n    deployment_type=\"git\",\n    environment_variables={\n        \"LOG_LEVEL\": \"info\",\n        \"NODE_ENV\": \"production\",\n    },\n    git_branch=\"main\",\n    git_repository=\"https://github.com/user/my-app\",\n    max_instances=5,\n    min_instances=1,\n    port=8080)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing DanubeData = DanubeData.DanubeData;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var app = new DanubeData.Serverless(\"app\", new()\n    {\n        DeploymentType = \"git\",\n        EnvironmentVariables = \n        {\n            { \"LOG_LEVEL\", \"info\" },\n            { \"NODE_ENV\", \"production\" },\n        },\n        GitBranch = \"main\",\n        GitRepository = \"https://github.com/user/my-app\",\n        MaxInstances = 5,\n        MinInstances = 1,\n        Port = 8080,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/AdrianSilaghi/pulumi-danubedata/sdk/go/danubedata\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := danubedata.NewServerless(ctx, \"app\", \u0026danubedata.ServerlessArgs{\n\t\t\tDeploymentType: pulumi.String(\"git\"),\n\t\t\tEnvironmentVariables: pulumi.StringMap{\n\t\t\t\t\"LOG_LEVEL\": pulumi.String(\"info\"),\n\t\t\t\t\"NODE_ENV\":  pulumi.String(\"production\"),\n\t\t\t},\n\t\t\tGitBranch:     pulumi.String(\"main\"),\n\t\t\tGitRepository: pulumi.String(\"https://github.com/user/my-app\"),\n\t\t\tMaxInstances:  pulumi.Int(5),\n\t\t\tMinInstances:  pulumi.Int(1),\n\t\t\tPort:          pulumi.Int(8080),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.danubedata.Serverless;\nimport com.pulumi.danubedata.ServerlessArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var app = new Serverless(\"app\", ServerlessArgs.builder()\n            .deploymentType(\"git\")\n            .environmentVariables(Map.ofEntries(\n                Map.entry(\"LOG_LEVEL\", \"info\"),\n                Map.entry(\"NODE_ENV\", \"production\")\n            ))\n            .gitBranch(\"main\")\n            .gitRepository(\"https://github.com/user/my-app\")\n            .maxInstances(5)\n            .minInstances(1)\n            .port(8080)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  app:\n    type: danubedata:Serverless\n    properties:\n      deploymentType: git\n      environmentVariables:\n        LOG_LEVEL: info\n        NODE_ENV: production\n      gitBranch: main\n      gitRepository: https://github.com/user/my-app\n      maxInstances: 5\n      minInstances: 1\n      port: 8080\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### With Resource Profile\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as danubedata from \"@danubedata/pulumi\";\n\nconst api = new danubedata.Serverless(\"api\", {\n    deploymentType: \"docker\",\n    environmentVariables: {\n        DATABASE_URL: \"postgres://...\",\n        REDIS_URL: \"redis://...\",\n    },\n    imageUrl: \"myregistry/api:v1.0\",\n    maxInstances: 20,\n    minInstances: 2,\n    port: 3000,\n    resourceProfile: \"medium\",\n});\n```\n```python\nimport pulumi\nimport pulumi_danubedata as danubedata\n\napi = danubedata.Serverless(\"api\",\n    deployment_type=\"docker\",\n    environment_variables={\n        \"DATABASE_URL\": \"postgres://...\",\n        \"REDIS_URL\": \"redis://...\",\n    },\n    image_url=\"myregistry/api:v1.0\",\n    max_instances=20,\n    min_instances=2,\n    port=3000,\n    resource_profile=\"medium\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing DanubeData = DanubeData.DanubeData;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var api = new DanubeData.Serverless(\"api\", new()\n    {\n        DeploymentType = \"docker\",\n        EnvironmentVariables = \n        {\n            { \"DATABASE_URL\", \"postgres://...\" },\n            { \"REDIS_URL\", \"redis://...\" },\n        },\n        ImageUrl = \"myregistry/api:v1.0\",\n        MaxInstances = 20,\n        MinInstances = 2,\n        Port = 3000,\n        ResourceProfile = \"medium\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/AdrianSilaghi/pulumi-danubedata/sdk/go/danubedata\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := danubedata.NewServerless(ctx, \"api\", \u0026danubedata.ServerlessArgs{\n\t\t\tDeploymentType: pulumi.String(\"docker\"),\n\t\t\tEnvironmentVariables: pulumi.StringMap{\n\t\t\t\t\"DATABASE_URL\": pulumi.String(\"postgres://...\"),\n\t\t\t\t\"REDIS_URL\":    pulumi.String(\"redis://...\"),\n\t\t\t},\n\t\t\tImageUrl:        pulumi.String(\"myregistry/api:v1.0\"),\n\t\t\tMaxInstances:    pulumi.Int(20),\n\t\t\tMinInstances:    pulumi.Int(2),\n\t\t\tPort:            pulumi.Int(3000),\n\t\t\tResourceProfile: pulumi.String(\"medium\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.danubedata.Serverless;\nimport com.pulumi.danubedata.ServerlessArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var api = new Serverless(\"api\", ServerlessArgs.builder()\n            .deploymentType(\"docker\")\n            .environmentVariables(Map.ofEntries(\n                Map.entry(\"DATABASE_URL\", \"postgres://...\"),\n                Map.entry(\"REDIS_URL\", \"redis://...\")\n            ))\n            .imageUrl(\"myregistry/api:v1.0\")\n            .maxInstances(20)\n            .minInstances(2)\n            .port(3000)\n            .resourceProfile(\"medium\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  api:\n    type: danubedata:Serverless\n    properties:\n      deploymentType: docker\n      environmentVariables:\n        DATABASE_URL: postgres://...\n        REDIS_URL: redis://...\n      imageUrl: myregistry/api:v1.0\n      maxInstances: 20\n      minInstances: 2\n      port: 3000\n      resourceProfile: medium\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Scale to Zero Configuration\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as danubedata from \"@danubedata/pulumi\";\n\nconst webhook = new danubedata.Serverless(\"webhook\", {\n    deploymentType: \"docker\",\n    imageUrl: \"myregistry/webhook:latest\",\n    maxInstances: 100,\n    minInstances: 0,\n    port: 8080,\n});\n```\n```python\nimport pulumi\nimport pulumi_danubedata as danubedata\n\nwebhook = danubedata.Serverless(\"webhook\",\n    deployment_type=\"docker\",\n    image_url=\"myregistry/webhook:latest\",\n    max_instances=100,\n    min_instances=0,\n    port=8080)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing DanubeData = DanubeData.DanubeData;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var webhook = new DanubeData.Serverless(\"webhook\", new()\n    {\n        DeploymentType = \"docker\",\n        ImageUrl = \"myregistry/webhook:latest\",\n        MaxInstances = 100,\n        MinInstances = 0,\n        Port = 8080,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/AdrianSilaghi/pulumi-danubedata/sdk/go/danubedata\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := danubedata.NewServerless(ctx, \"webhook\", \u0026danubedata.ServerlessArgs{\n\t\t\tDeploymentType: pulumi.String(\"docker\"),\n\t\t\tImageUrl:       pulumi.String(\"myregistry/webhook:latest\"),\n\t\t\tMaxInstances:   pulumi.Int(100),\n\t\t\tMinInstances:   pulumi.Int(0),\n\t\t\tPort:           pulumi.Int(8080),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.danubedata.Serverless;\nimport com.pulumi.danubedata.ServerlessArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var webhook = new Serverless(\"webhook\", ServerlessArgs.builder()\n            .deploymentType(\"docker\")\n            .imageUrl(\"myregistry/webhook:latest\")\n            .maxInstances(100)\n            .minInstances(0)\n            .port(8080)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  webhook:\n    type: danubedata:Serverless\n    properties:\n      deploymentType: docker\n      imageUrl: myregistry/webhook:latest\n      maxInstances: 100\n      minInstances: 0\n      port: 8080\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Scaling Behavior\n\n- **min_instances = 0**: Container scales to zero after idle period (cost-effective)\n- **min_instances \u003e= 1**: Always keeps instances running (no cold starts)\n- Scales up automatically based on traffic\n- Scales down when traffic decreases\n\n## Build Process (Git Deployment)\n\nWhen using `git` deployment type:\n1. Repository is cloned\n2. Buildpack detection or Dockerfile is used\n3. Container image is built\n4. Image is deployed to serverless platform\n5. Automatic rebuilds on git push (via webhook)\n\n## Import\n\nServerless containers can be imported using their ID:\n\nbash\n\n```sh\n$ pulumi import danubedata:index/serverless:Serverless example srv-abc123\n```\n\n",
            "properties": {
                "createdAt": {
                    "type": "string",
                    "description": "Creation timestamp.\n"
                },
                "currentMonthCostCents": {
                    "type": "integer",
                    "description": "Current month's cost in cents.\n"
                },
                "deploymentType": {
                    "type": "string",
                    "description": "Deployment type: 'image' for Docker image, 'git' for Git repository.\n"
                },
                "environmentVariables": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Environment variables for the container.\n"
                },
                "gitBranch": {
                    "type": "string",
                    "description": "Git branch to deploy.\n"
                },
                "gitRepository": {
                    "type": "string",
                    "description": "Git repository URL (required if deployment_type is 'git').\n"
                },
                "imageUrl": {
                    "type": "string",
                    "description": "Docker image URL (required if deployment_type is 'image').\n"
                },
                "maxInstances": {
                    "type": "integer",
                    "description": "Maximum number of instances.\n"
                },
                "minInstances": {
                    "type": "integer",
                    "description": "Minimum number of instances (0 for scale-to-zero).\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the serverless container.\n"
                },
                "port": {
                    "type": "integer",
                    "description": "Port the container listens on.\n"
                },
                "resourceProfile": {
                    "type": "string",
                    "description": "Resource profile for the container (small, medium, large).\n"
                },
                "status": {
                    "type": "string",
                    "description": "Current status.\n"
                },
                "timeouts": {
                    "$ref": "#/types/danubedata:index/ServerlessTimeouts:ServerlessTimeouts"
                },
                "updatedAt": {
                    "type": "string",
                    "description": "Timestamp when the container was last updated.\n"
                },
                "url": {
                    "type": "string",
                    "description": "Public HTTPS URL for the container.\n"
                }
            },
            "required": [
                "createdAt",
                "currentMonthCostCents",
                "deploymentType",
                "gitBranch",
                "maxInstances",
                "minInstances",
                "name",
                "port",
                "resourceProfile",
                "status",
                "updatedAt",
                "url"
            ],
            "inputProperties": {
                "deploymentType": {
                    "type": "string",
                    "description": "Deployment type: 'image' for Docker image, 'git' for Git repository.\n"
                },
                "environmentVariables": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Environment variables for the container.\n"
                },
                "gitBranch": {
                    "type": "string",
                    "description": "Git branch to deploy.\n"
                },
                "gitRepository": {
                    "type": "string",
                    "description": "Git repository URL (required if deployment_type is 'git').\n"
                },
                "imageUrl": {
                    "type": "string",
                    "description": "Docker image URL (required if deployment_type is 'image').\n"
                },
                "maxInstances": {
                    "type": "integer",
                    "description": "Maximum number of instances.\n"
                },
                "minInstances": {
                    "type": "integer",
                    "description": "Minimum number of instances (0 for scale-to-zero).\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the serverless container.\n"
                },
                "port": {
                    "type": "integer",
                    "description": "Port the container listens on.\n"
                },
                "resourceProfile": {
                    "type": "string",
                    "description": "Resource profile for the container (small, medium, large).\n"
                },
                "timeouts": {
                    "$ref": "#/types/danubedata:index/ServerlessTimeouts:ServerlessTimeouts"
                }
            },
            "requiredInputs": [
                "deploymentType"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Serverless resources.\n",
                "properties": {
                    "createdAt": {
                        "type": "string",
                        "description": "Creation timestamp.\n"
                    },
                    "currentMonthCostCents": {
                        "type": "integer",
                        "description": "Current month's cost in cents.\n"
                    },
                    "deploymentType": {
                        "type": "string",
                        "description": "Deployment type: 'image' for Docker image, 'git' for Git repository.\n"
                    },
                    "environmentVariables": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Environment variables for the container.\n"
                    },
                    "gitBranch": {
                        "type": "string",
                        "description": "Git branch to deploy.\n"
                    },
                    "gitRepository": {
                        "type": "string",
                        "description": "Git repository URL (required if deployment_type is 'git').\n"
                    },
                    "imageUrl": {
                        "type": "string",
                        "description": "Docker image URL (required if deployment_type is 'image').\n"
                    },
                    "maxInstances": {
                        "type": "integer",
                        "description": "Maximum number of instances.\n"
                    },
                    "minInstances": {
                        "type": "integer",
                        "description": "Minimum number of instances (0 for scale-to-zero).\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the serverless container.\n"
                    },
                    "port": {
                        "type": "integer",
                        "description": "Port the container listens on.\n"
                    },
                    "resourceProfile": {
                        "type": "string",
                        "description": "Resource profile for the container (small, medium, large).\n"
                    },
                    "status": {
                        "type": "string",
                        "description": "Current status.\n"
                    },
                    "timeouts": {
                        "$ref": "#/types/danubedata:index/ServerlessTimeouts:ServerlessTimeouts"
                    },
                    "updatedAt": {
                        "type": "string",
                        "description": "Timestamp when the container was last updated.\n"
                    },
                    "url": {
                        "type": "string",
                        "description": "Public HTTPS URL for the container.\n"
                    }
                },
                "type": "object"
            }
        },
        "danubedata:index/sshKey:SshKey": {
            "description": "## # danubedata.SshKey\n\nManages an SSH key for VPS authentication.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as danubedata from \"@danubedata/pulumi\";\nimport * as fs from \"fs\";\n\nconst main = new danubedata.SshKey(\"main\", {publicKey: fs.readFileSync(\"~/.ssh/id_ed25519.pub\", \"utf8\")});\n```\n```python\nimport pulumi\nimport pulumi_danubedata as danubedata\n\nmain = danubedata.SshKey(\"main\", public_key=(lambda path: open(path).read())(\"~/.ssh/id_ed25519.pub\"))\n```\n```csharp\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing Pulumi;\nusing DanubeData = DanubeData.DanubeData;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var main = new DanubeData.SshKey(\"main\", new()\n    {\n        PublicKey = File.ReadAllText(\"~/.ssh/id_ed25519.pub\"),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"os\"\n\n\t\"github.com/AdrianSilaghi/pulumi-danubedata/sdk/go/danubedata\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc readFileOrPanic(path string) pulumi.StringPtrInput {\n\tdata, err := os.ReadFile(path)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\treturn pulumi.String(string(data))\n}\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := danubedata.NewSshKey(ctx, \"main\", \u0026danubedata.SshKeyArgs{\n\t\t\tPublicKey: pulumi.String(readFileOrPanic(\"~/.ssh/id_ed25519.pub\")),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.danubedata.SshKey;\nimport com.pulumi.danubedata.SshKeyArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var main = new SshKey(\"main\", SshKeyArgs.builder()\n            .publicKey(Files.readString(Paths.get(\"~/.ssh/id_ed25519.pub\")))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  main:\n    type: danubedata:SshKey\n    properties:\n      publicKey:\n        fn::readFile: ~/.ssh/id_ed25519.pub\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Using with VPS\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as danubedata from \"@danubedata/pulumi\";\n\nconst deploy = new danubedata.SshKey(\"deploy\", {publicKey: \"ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAA... deploy@example.com\"});\nconst server = new danubedata.Vps(\"server\", {\n    image: \"ubuntu-22.04\",\n    datacenter: \"fsn1\",\n    authMethod: \"ssh_key\",\n    sshKeyId: deploy.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_danubedata as danubedata\n\ndeploy = danubedata.SshKey(\"deploy\", public_key=\"ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAA... deploy@example.com\")\nserver = danubedata.Vps(\"server\",\n    image=\"ubuntu-22.04\",\n    datacenter=\"fsn1\",\n    auth_method=\"ssh_key\",\n    ssh_key_id=deploy.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing DanubeData = DanubeData.DanubeData;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var deploy = new DanubeData.SshKey(\"deploy\", new()\n    {\n        PublicKey = \"ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAA... deploy@example.com\",\n    });\n\n    var server = new DanubeData.Vps(\"server\", new()\n    {\n        Image = \"ubuntu-22.04\",\n        Datacenter = \"fsn1\",\n        AuthMethod = \"ssh_key\",\n        SshKeyId = deploy.Id,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/AdrianSilaghi/pulumi-danubedata/sdk/go/danubedata\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdeploy, err := danubedata.NewSshKey(ctx, \"deploy\", \u0026danubedata.SshKeyArgs{\n\t\t\tPublicKey: pulumi.String(\"ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAA... deploy@example.com\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = danubedata.NewVps(ctx, \"server\", \u0026danubedata.VpsArgs{\n\t\t\tImage:      pulumi.String(\"ubuntu-22.04\"),\n\t\t\tDatacenter: pulumi.String(\"fsn1\"),\n\t\t\tAuthMethod: pulumi.String(\"ssh_key\"),\n\t\t\tSshKeyId:   deploy.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.danubedata.SshKey;\nimport com.pulumi.danubedata.SshKeyArgs;\nimport com.pulumi.danubedata.Vps;\nimport com.pulumi.danubedata.VpsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var deploy = new SshKey(\"deploy\", SshKeyArgs.builder()\n            .publicKey(\"ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAA... deploy@example.com\")\n            .build());\n\n        var server = new Vps(\"server\", VpsArgs.builder()\n            .image(\"ubuntu-22.04\")\n            .datacenter(\"fsn1\")\n            .authMethod(\"ssh_key\")\n            .sshKeyId(deploy.id())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  deploy:\n    type: danubedata:SshKey\n    properties:\n      publicKey: ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAA... deploy@example.com\n  server:\n    type: danubedata:Vps\n    properties:\n      image: ubuntu-22.04\n      datacenter: fsn1\n      authMethod: ssh_key\n      sshKeyId: ${deploy.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nSSH keys can be imported using their ID:\n\nbash\n\n```sh\n$ pulumi import danubedata:index/sshKey:SshKey example key-abc123\n```\n\n",
            "properties": {
                "createdAt": {
                    "type": "string",
                    "description": "Creation timestamp.\n"
                },
                "fingerprint": {
                    "type": "string",
                    "description": "The SSH key fingerprint.\n"
                },
                "name": {
                    "type": "string",
                    "description": "A descriptive name for the SSH key.\n"
                },
                "publicKey": {
                    "type": "string",
                    "description": "The SSH public key in OpenSSH format (e.g., 'ssh-rsa AAAA...' or 'ssh-ed25519 AAAA...').\n"
                },
                "updatedAt": {
                    "type": "string",
                    "description": "Timestamp when the SSH key was last updated.\n"
                }
            },
            "required": [
                "createdAt",
                "fingerprint",
                "name",
                "publicKey",
                "updatedAt"
            ],
            "inputProperties": {
                "name": {
                    "type": "string",
                    "description": "A descriptive name for the SSH key.\n"
                },
                "publicKey": {
                    "type": "string",
                    "description": "The SSH public key in OpenSSH format (e.g., 'ssh-rsa AAAA...' or 'ssh-ed25519 AAAA...').\n"
                }
            },
            "requiredInputs": [
                "publicKey"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SshKey resources.\n",
                "properties": {
                    "createdAt": {
                        "type": "string",
                        "description": "Creation timestamp.\n"
                    },
                    "fingerprint": {
                        "type": "string",
                        "description": "The SSH key fingerprint.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "A descriptive name for the SSH key.\n"
                    },
                    "publicKey": {
                        "type": "string",
                        "description": "The SSH public key in OpenSSH format (e.g., 'ssh-rsa AAAA...' or 'ssh-ed25519 AAAA...').\n"
                    },
                    "updatedAt": {
                        "type": "string",
                        "description": "Timestamp when the SSH key was last updated.\n"
                    }
                },
                "type": "object"
            }
        },
        "danubedata:index/storageAccessKey:StorageAccessKey": {
            "description": "## # danubedata.StorageAccessKey\n\nManages an S3-compatible storage access key for bucket authentication.\n\n## Example Usage\n\n### Basic Access Key\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as danubedata from \"@danubedata/pulumi\";\n\nconst main = new danubedata.StorageAccessKey(\"main\", {});\nexport const accessKeyId = main.accessKeyId;\nexport const secretAccessKey = main.secretAccessKey;\n```\n```python\nimport pulumi\nimport pulumi_danubedata as danubedata\n\nmain = danubedata.StorageAccessKey(\"main\")\npulumi.export(\"accessKeyId\", main.access_key_id)\npulumi.export(\"secretAccessKey\", main.secret_access_key)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing DanubeData = DanubeData.DanubeData;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var main = new DanubeData.StorageAccessKey(\"main\");\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"accessKeyId\"] = main.AccessKeyId,\n        [\"secretAccessKey\"] = main.SecretAccessKey,\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/AdrianSilaghi/pulumi-danubedata/sdk/go/danubedata\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tmain, err := danubedata.NewStorageAccessKey(ctx, \"main\", nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"accessKeyId\", main.AccessKeyId)\n\t\tctx.Export(\"secretAccessKey\", main.SecretAccessKey)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.danubedata.StorageAccessKey;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var main = new StorageAccessKey(\"main\");\n\n        ctx.export(\"accessKeyId\", main.accessKeyId());\n        ctx.export(\"secretAccessKey\", main.secretAccessKey());\n    }\n}\n```\n```yaml\nresources:\n  main:\n    type: danubedata:StorageAccessKey\noutputs:\n  accessKeyId: ${main.accessKeyId}\n  secretAccessKey: ${main.secretAccessKey}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Using with AWS Provider for S3 Operations\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as aws from \"@pulumi/aws\";\nimport * as danubedata from \"@danubedata/pulumi\";\n\nconst data = new danubedata.StorageBucket(\"data\", {region: \"fsn1\"});\nconst s3 = new danubedata.StorageAccessKey(\"s3\", {});\nconst example = new aws.index.Aws_s3_object(\"example\", {\n    bucket: data.minioBucketName,\n    key: \"example.txt\",\n    content: \"Hello, World!\",\n}, {\n    provider: aws.danubedata,\n});\n```\n```python\nimport pulumi\nimport pulumi_aws as aws\nimport pulumi_danubedata as danubedata\n\ndata = danubedata.StorageBucket(\"data\", region=\"fsn1\")\ns3 = danubedata.StorageAccessKey(\"s3\")\ndanubedata = aws.Provider(\"danubedata\",\n    region=\"us-east-1\",\n    access_key=s3.access_key_id,\n    secret_key=s3.secret_access_key,\n    endpoints=[{\n        \"s3\": data.endpoint_url,\n    }],\n    skip_credentials_validation=True,\n    skip_metadata_api_check=True,\n    skip_requesting_account_id=True,\n    s3_use_path_style=True)\nexample = aws.s3.BucketObjectv2(\"example\",\n    bucket=data.minio_bucket_name,\n    key=\"example.txt\",\n    content=\"Hello, World!\",\n    opts = pulumi.ResourceOptions(provider=aws[\"danubedata\"]))\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Aws = Pulumi.Aws;\nusing DanubeData = DanubeData.DanubeData;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var data = new DanubeData.StorageBucket(\"data\", new()\n    {\n        Region = \"fsn1\",\n    });\n\n    var s3 = new DanubeData.StorageAccessKey(\"s3\");\n\n    var danubedata = new Aws.Provider(\"danubedata\", new()\n    {\n        Region = \"us-east-1\",\n        AccessKey = s3.AccessKeyId,\n        SecretKey = s3.SecretAccessKey,\n        Endpoints = new[]\n        {\n            new Aws.Inputs.ProviderEndpointArgs\n            {\n                S3 = data.EndpointUrl,\n            },\n        },\n        SkipCredentialsValidation = true,\n        SkipMetadataApiCheck = true,\n        SkipRequestingAccountId = true,\n        S3UsePathStyle = true,\n    });\n\n    var example = new Aws.S3.BucketObjectv2(\"example\", new()\n    {\n        Bucket = data.MinioBucketName,\n        Key = \"example.txt\",\n        Content = \"Hello, World!\",\n    }, new CustomResourceOptions\n    {\n        Provider = aws.Danubedata,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/AdrianSilaghi/pulumi-danubedata/sdk/go/danubedata\"\n\t\"github.com/pulumi/pulumi-aws/sdk/v7/go/aws\"\n\t\"github.com/pulumi/pulumi-aws/sdk/v7/go/aws/s3\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdata, err := danubedata.NewStorageBucket(ctx, \"data\", \u0026danubedata.StorageBucketArgs{\n\t\t\tRegion: pulumi.String(\"fsn1\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ts3, err := danubedata.NewStorageAccessKey(ctx, \"s3\", nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = aws.NewProvider(ctx, \"danubedata\", \u0026aws.ProviderArgs{\n\t\t\tRegion:    pulumi.String(\"us-east-1\"),\n\t\t\tAccessKey: s3.AccessKeyId,\n\t\t\tSecretKey: s3.SecretAccessKey,\n\t\t\tEndpoints: aws.ProviderEndpointArray{\n\t\t\t\t\u0026aws.ProviderEndpointArgs{\n\t\t\t\t\tS3: data.EndpointUrl,\n\t\t\t\t},\n\t\t\t},\n\t\t\tSkipCredentialsValidation: pulumi.Bool(true),\n\t\t\tSkipMetadataApiCheck:      pulumi.Bool(true),\n\t\t\tSkipRequestingAccountId:   pulumi.Bool(true),\n\t\t\tS3UsePathStyle:            pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = s3.NewBucketObjectv2(ctx, \"example\", \u0026s3.BucketObjectv2Args{\n\t\t\tBucket:  data.MinioBucketName,\n\t\t\tKey:     pulumi.String(\"example.txt\"),\n\t\t\tContent: pulumi.String(\"Hello, World!\"),\n\t\t}, pulumi.Provider(aws.Danubedata))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.danubedata.StorageBucket;\nimport com.pulumi.danubedata.StorageBucketArgs;\nimport com.pulumi.danubedata.StorageAccessKey;\nimport com.pulumi.aws.Provider;\nimport com.pulumi.aws.ProviderArgs;\nimport com.pulumi.aws.inputs.ProviderEndpointArgs;\nimport com.pulumi.aws.s3.BucketObjectv2;\nimport com.pulumi.aws.s3.BucketObjectv2Args;\nimport com.pulumi.resources.CustomResourceOptions;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var data = new StorageBucket(\"data\", StorageBucketArgs.builder()\n            .region(\"fsn1\")\n            .build());\n\n        var s3 = new StorageAccessKey(\"s3\");\n\n        var danubedata = new Provider(\"danubedata\", ProviderArgs.builder()\n            .region(\"us-east-1\")\n            .accessKey(s3.accessKeyId())\n            .secretKey(s3.secretAccessKey())\n            .endpoints(ProviderEndpointArgs.builder()\n                .s3(data.endpointUrl())\n                .build())\n            .skipCredentialsValidation(true)\n            .skipMetadataApiCheck(true)\n            .skipRequestingAccountId(true)\n            .s3UsePathStyle(true)\n            .build());\n\n        var example = new BucketObjectv2(\"example\", BucketObjectv2Args.builder()\n            .bucket(data.minioBucketName())\n            .key(\"example.txt\")\n            .content(\"Hello, World!\")\n            .build(), CustomResourceOptions.builder()\n                .provider(aws.danubedata())\n                .build());\n\n    }\n}\n```\n```yaml\nresources:\n  data:\n    type: danubedata:StorageBucket\n    properties:\n      region: fsn1\n  s3:\n    type: danubedata:StorageAccessKey\n  danubedata:\n    type: pulumi:providers:aws\n    properties:\n      region: us-east-1 # Required but ignored\n      accessKey: ${s3.accessKeyId}\n      secretKey: ${s3.secretAccessKey}\n      endpoints:\n        - s3: ${data.endpointUrl}\n      skipCredentialsValidation: true\n      skipMetadataApiCheck: true\n      skipRequestingAccountId: true\n      s3UsePathStyle: true\n  example:\n    type: aws:s3:BucketObjectv2\n    properties:\n      bucket: ${data.minioBucketName}\n      key: example.txt\n      content: Hello, World!\n    options:\n      provider: ${aws.danubedata}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nStorage access keys can be imported using their ID:\n\nbash\n\n```sh\n$ pulumi import danubedata:index/storageAccessKey:StorageAccessKey example key-abc123\n```\n\n",
            "properties": {
                "accessKeyId": {
                    "type": "string",
                    "description": "The S3 access key ID for authentication.\n"
                },
                "createdAt": {
                    "type": "string",
                    "description": "Creation timestamp.\n"
                },
                "expiresAt": {
                    "type": "string",
                    "description": "Optional expiration date for the access key (ISO 8601 format).\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the access key.\n"
                },
                "secretAccessKey": {
                    "type": "string",
                    "description": "The S3 secret access key for authentication. Only available after creation.\n",
                    "secret": true
                },
                "status": {
                    "type": "string",
                    "description": "Current status of the key.\n"
                },
                "updatedAt": {
                    "type": "string",
                    "description": "Timestamp when the access key was last updated.\n"
                }
            },
            "required": [
                "accessKeyId",
                "createdAt",
                "name",
                "secretAccessKey",
                "status",
                "updatedAt"
            ],
            "inputProperties": {
                "expiresAt": {
                    "type": "string",
                    "description": "Optional expiration date for the access key (ISO 8601 format).\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the access key.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering StorageAccessKey resources.\n",
                "properties": {
                    "accessKeyId": {
                        "type": "string",
                        "description": "The S3 access key ID for authentication.\n"
                    },
                    "createdAt": {
                        "type": "string",
                        "description": "Creation timestamp.\n"
                    },
                    "expiresAt": {
                        "type": "string",
                        "description": "Optional expiration date for the access key (ISO 8601 format).\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the access key.\n"
                    },
                    "secretAccessKey": {
                        "type": "string",
                        "description": "The S3 secret access key for authentication. Only available after creation.\n",
                        "secret": true
                    },
                    "status": {
                        "type": "string",
                        "description": "Current status of the key.\n"
                    },
                    "updatedAt": {
                        "type": "string",
                        "description": "Timestamp when the access key was last updated.\n"
                    }
                },
                "type": "object"
            }
        },
        "danubedata:index/storageBucket:StorageBucket": {
            "description": "## # danubedata.StorageBucket\n\nManages an S3-compatible object storage bucket.\n\n## Example Usage\n\n### Basic Bucket\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as danubedata from \"@danubedata/pulumi\";\n\nconst assets = new danubedata.StorageBucket(\"assets\", {region: \"fsn1\"});\nexport const bucketEndpoint = assets.endpointUrl;\n```\n```python\nimport pulumi\nimport pulumi_danubedata as danubedata\n\nassets = danubedata.StorageBucket(\"assets\", region=\"fsn1\")\npulumi.export(\"bucketEndpoint\", assets.endpoint_url)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing DanubeData = DanubeData.DanubeData;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var assets = new DanubeData.StorageBucket(\"assets\", new()\n    {\n        Region = \"fsn1\",\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"bucketEndpoint\"] = assets.EndpointUrl,\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/AdrianSilaghi/pulumi-danubedata/sdk/go/danubedata\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tassets, err := danubedata.NewStorageBucket(ctx, \"assets\", \u0026danubedata.StorageBucketArgs{\n\t\t\tRegion: pulumi.String(\"fsn1\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"bucketEndpoint\", assets.EndpointUrl)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.danubedata.StorageBucket;\nimport com.pulumi.danubedata.StorageBucketArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var assets = new StorageBucket(\"assets\", StorageBucketArgs.builder()\n            .region(\"fsn1\")\n            .build());\n\n        ctx.export(\"bucketEndpoint\", assets.endpointUrl());\n    }\n}\n```\n```yaml\nresources:\n  assets:\n    type: danubedata:StorageBucket\n    properties:\n      region: fsn1\noutputs:\n  bucketEndpoint: ${assets.endpointUrl}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Bucket with Versioning\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as danubedata from \"@danubedata/pulumi\";\n\nconst backups = new danubedata.StorageBucket(\"backups\", {\n    region: \"fsn1\",\n    versioningEnabled: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_danubedata as danubedata\n\nbackups = danubedata.StorageBucket(\"backups\",\n    region=\"fsn1\",\n    versioning_enabled=True)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing DanubeData = DanubeData.DanubeData;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var backups = new DanubeData.StorageBucket(\"backups\", new()\n    {\n        Region = \"fsn1\",\n        VersioningEnabled = true,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/AdrianSilaghi/pulumi-danubedata/sdk/go/danubedata\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := danubedata.NewStorageBucket(ctx, \"backups\", \u0026danubedata.StorageBucketArgs{\n\t\t\tRegion:            pulumi.String(\"fsn1\"),\n\t\t\tVersioningEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.danubedata.StorageBucket;\nimport com.pulumi.danubedata.StorageBucketArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var backups = new StorageBucket(\"backups\", StorageBucketArgs.builder()\n            .region(\"fsn1\")\n            .versioningEnabled(true)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  backups:\n    type: danubedata:StorageBucket\n    properties:\n      region: fsn1\n      versioningEnabled: true\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Public Bucket\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as danubedata from \"@danubedata/pulumi\";\n\nconst _public = new danubedata.StorageBucket(\"public\", {\n    publicAccess: true,\n    region: \"fsn1\",\n});\n```\n```python\nimport pulumi\nimport pulumi_danubedata as danubedata\n\npublic = danubedata.StorageBucket(\"public\",\n    public_access=True,\n    region=\"fsn1\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing DanubeData = DanubeData.DanubeData;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var @public = new DanubeData.StorageBucket(\"public\", new()\n    {\n        PublicAccess = true,\n        Region = \"fsn1\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/AdrianSilaghi/pulumi-danubedata/sdk/go/danubedata\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := danubedata.NewStorageBucket(ctx, \"public\", \u0026danubedata.StorageBucketArgs{\n\t\t\tPublicAccess: pulumi.Bool(true),\n\t\t\tRegion:       pulumi.String(\"fsn1\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.danubedata.StorageBucket;\nimport com.pulumi.danubedata.StorageBucketArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var public_ = new StorageBucket(\"public\", StorageBucketArgs.builder()\n            .publicAccess(true)\n            .region(\"fsn1\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  public:\n    type: danubedata:StorageBucket\n    properties:\n      publicAccess: true\n      region: fsn1\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Complete Configuration\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as danubedata from \"@danubedata/pulumi\";\n\nconst data = new danubedata.StorageBucket(\"data\", {\n    displayName: \"Application Data\",\n    encryptionEnabled: true,\n    publicAccess: false,\n    region: \"fsn1\",\n    versioningEnabled: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_danubedata as danubedata\n\ndata = danubedata.StorageBucket(\"data\",\n    display_name=\"Application Data\",\n    encryption_enabled=True,\n    public_access=False,\n    region=\"fsn1\",\n    versioning_enabled=True)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing DanubeData = DanubeData.DanubeData;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var data = new DanubeData.StorageBucket(\"data\", new()\n    {\n        DisplayName = \"Application Data\",\n        EncryptionEnabled = true,\n        PublicAccess = false,\n        Region = \"fsn1\",\n        VersioningEnabled = true,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/AdrianSilaghi/pulumi-danubedata/sdk/go/danubedata\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := danubedata.NewStorageBucket(ctx, \"data\", \u0026danubedata.StorageBucketArgs{\n\t\t\tDisplayName:       pulumi.String(\"Application Data\"),\n\t\t\tEncryptionEnabled: pulumi.Bool(true),\n\t\t\tPublicAccess:      pulumi.Bool(false),\n\t\t\tRegion:            pulumi.String(\"fsn1\"),\n\t\t\tVersioningEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.danubedata.StorageBucket;\nimport com.pulumi.danubedata.StorageBucketArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var data = new StorageBucket(\"data\", StorageBucketArgs.builder()\n            .displayName(\"Application Data\")\n            .encryptionEnabled(true)\n            .publicAccess(false)\n            .region(\"fsn1\")\n            .versioningEnabled(true)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  data:\n    type: danubedata:StorageBucket\n    properties:\n      displayName: Application Data\n      encryptionEnabled: true\n      publicAccess: false\n      region: fsn1\n      versioningEnabled: true\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Pricing\n\n- Base: EUR 3.99/month\n- Includes: 1TB storage + 1TB egress traffic\n- Overage: EUR 0.01/GB for storage, EUR 0.01/GB for egress\n\n## Import\n\nStorage buckets can be imported using their ID:\n\nbash\n\n```sh\n$ pulumi import danubedata:index/storageBucket:StorageBucket example bucket-abc123\n```\n\n",
            "properties": {
                "createdAt": {
                    "type": "string",
                    "description": "Creation timestamp.\n"
                },
                "displayName": {
                    "type": "string",
                    "description": "Human-readable display name for the bucket.\n"
                },
                "encryptionEnabled": {
                    "type": "boolean",
                    "description": "Whether server-side encryption is enabled.\n"
                },
                "encryptionType": {
                    "type": "string",
                    "description": "Encryption type (none, sse-s3, sse-kms).\n"
                },
                "endpointUrl": {
                    "type": "string",
                    "description": "S3-compatible endpoint URL.\n"
                },
                "minioBucketName": {
                    "type": "string",
                    "description": "Internal bucket name.\n"
                },
                "monthlyCost": {
                    "type": "number",
                    "description": "Estimated monthly cost.\n"
                },
                "monthlyCostCents": {
                    "type": "integer",
                    "description": "Monthly cost in cents.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the storage bucket. Must follow S3 bucket naming rules (3-63 chars, lowercase alphanumeric with hyphens).\n"
                },
                "objectCount": {
                    "type": "integer",
                    "description": "Number of objects.\n"
                },
                "publicAccess": {
                    "type": "boolean",
                    "description": "Whether the bucket has public read access enabled.\n"
                },
                "region": {
                    "type": "string",
                    "description": "Region for the storage bucket (fsn1).\n"
                },
                "sizeBytes": {
                    "type": "integer",
                    "description": "Current size in bytes.\n"
                },
                "status": {
                    "type": "string",
                    "description": "Current status.\n"
                },
                "timeouts": {
                    "$ref": "#/types/danubedata:index/StorageBucketTimeouts:StorageBucketTimeouts"
                },
                "updatedAt": {
                    "type": "string",
                    "description": "Timestamp when the bucket was last updated.\n"
                },
                "versioningEnabled": {
                    "type": "boolean",
                    "description": "Whether object versioning is enabled.\n"
                }
            },
            "required": [
                "createdAt",
                "encryptionEnabled",
                "encryptionType",
                "endpointUrl",
                "minioBucketName",
                "monthlyCost",
                "monthlyCostCents",
                "name",
                "objectCount",
                "publicAccess",
                "region",
                "sizeBytes",
                "status",
                "updatedAt",
                "versioningEnabled"
            ],
            "inputProperties": {
                "displayName": {
                    "type": "string",
                    "description": "Human-readable display name for the bucket.\n"
                },
                "encryptionEnabled": {
                    "type": "boolean",
                    "description": "Whether server-side encryption is enabled.\n"
                },
                "encryptionType": {
                    "type": "string",
                    "description": "Encryption type (none, sse-s3, sse-kms).\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the storage bucket. Must follow S3 bucket naming rules (3-63 chars, lowercase alphanumeric with hyphens).\n"
                },
                "publicAccess": {
                    "type": "boolean",
                    "description": "Whether the bucket has public read access enabled.\n"
                },
                "region": {
                    "type": "string",
                    "description": "Region for the storage bucket (fsn1).\n"
                },
                "timeouts": {
                    "$ref": "#/types/danubedata:index/StorageBucketTimeouts:StorageBucketTimeouts"
                },
                "versioningEnabled": {
                    "type": "boolean",
                    "description": "Whether object versioning is enabled.\n"
                }
            },
            "requiredInputs": [
                "region"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering StorageBucket resources.\n",
                "properties": {
                    "createdAt": {
                        "type": "string",
                        "description": "Creation timestamp.\n"
                    },
                    "displayName": {
                        "type": "string",
                        "description": "Human-readable display name for the bucket.\n"
                    },
                    "encryptionEnabled": {
                        "type": "boolean",
                        "description": "Whether server-side encryption is enabled.\n"
                    },
                    "encryptionType": {
                        "type": "string",
                        "description": "Encryption type (none, sse-s3, sse-kms).\n"
                    },
                    "endpointUrl": {
                        "type": "string",
                        "description": "S3-compatible endpoint URL.\n"
                    },
                    "minioBucketName": {
                        "type": "string",
                        "description": "Internal bucket name.\n"
                    },
                    "monthlyCost": {
                        "type": "number",
                        "description": "Estimated monthly cost.\n"
                    },
                    "monthlyCostCents": {
                        "type": "integer",
                        "description": "Monthly cost in cents.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the storage bucket. Must follow S3 bucket naming rules (3-63 chars, lowercase alphanumeric with hyphens).\n"
                    },
                    "objectCount": {
                        "type": "integer",
                        "description": "Number of objects.\n"
                    },
                    "publicAccess": {
                        "type": "boolean",
                        "description": "Whether the bucket has public read access enabled.\n"
                    },
                    "region": {
                        "type": "string",
                        "description": "Region for the storage bucket (fsn1).\n"
                    },
                    "sizeBytes": {
                        "type": "integer",
                        "description": "Current size in bytes.\n"
                    },
                    "status": {
                        "type": "string",
                        "description": "Current status.\n"
                    },
                    "timeouts": {
                        "$ref": "#/types/danubedata:index/StorageBucketTimeouts:StorageBucketTimeouts"
                    },
                    "updatedAt": {
                        "type": "string",
                        "description": "Timestamp when the bucket was last updated.\n"
                    },
                    "versioningEnabled": {
                        "type": "boolean",
                        "description": "Whether object versioning is enabled.\n"
                    }
                },
                "type": "object"
            }
        },
        "danubedata:index/vps:Vps": {
            "description": "## # danubedata.Vps\n\nManages a VPS (Virtual Private Server) instance.\n\n## Example Usage\n\n### Basic VPS with SSH Key\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as danubedata from \"@danubedata/pulumi\";\nimport * as fs from \"fs\";\n\nconst main = new danubedata.SshKey(\"main\", {publicKey: fs.readFileSync(\"~/.ssh/id_ed25519.pub\", \"utf8\")});\nconst web = new danubedata.Vps(\"web\", {\n    image: \"ubuntu-22.04\",\n    datacenter: \"fsn1\",\n    authMethod: \"ssh_key\",\n    sshKeyId: main.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_danubedata as danubedata\n\nmain = danubedata.SshKey(\"main\", public_key=(lambda path: open(path).read())(\"~/.ssh/id_ed25519.pub\"))\nweb = danubedata.Vps(\"web\",\n    image=\"ubuntu-22.04\",\n    datacenter=\"fsn1\",\n    auth_method=\"ssh_key\",\n    ssh_key_id=main.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing Pulumi;\nusing DanubeData = DanubeData.DanubeData;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var main = new DanubeData.SshKey(\"main\", new()\n    {\n        PublicKey = File.ReadAllText(\"~/.ssh/id_ed25519.pub\"),\n    });\n\n    var web = new DanubeData.Vps(\"web\", new()\n    {\n        Image = \"ubuntu-22.04\",\n        Datacenter = \"fsn1\",\n        AuthMethod = \"ssh_key\",\n        SshKeyId = main.Id,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"os\"\n\n\t\"github.com/AdrianSilaghi/pulumi-danubedata/sdk/go/danubedata\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc readFileOrPanic(path string) pulumi.StringPtrInput {\n\tdata, err := os.ReadFile(path)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\treturn pulumi.String(string(data))\n}\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tmain, err := danubedata.NewSshKey(ctx, \"main\", \u0026danubedata.SshKeyArgs{\n\t\t\tPublicKey: pulumi.String(readFileOrPanic(\"~/.ssh/id_ed25519.pub\")),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = danubedata.NewVps(ctx, \"web\", \u0026danubedata.VpsArgs{\n\t\t\tImage:      pulumi.String(\"ubuntu-22.04\"),\n\t\t\tDatacenter: pulumi.String(\"fsn1\"),\n\t\t\tAuthMethod: pulumi.String(\"ssh_key\"),\n\t\t\tSshKeyId:   main.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.danubedata.SshKey;\nimport com.pulumi.danubedata.SshKeyArgs;\nimport com.pulumi.danubedata.Vps;\nimport com.pulumi.danubedata.VpsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var main = new SshKey(\"main\", SshKeyArgs.builder()\n            .publicKey(Files.readString(Paths.get(\"~/.ssh/id_ed25519.pub\")))\n            .build());\n\n        var web = new Vps(\"web\", VpsArgs.builder()\n            .image(\"ubuntu-22.04\")\n            .datacenter(\"fsn1\")\n            .authMethod(\"ssh_key\")\n            .sshKeyId(main.id())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  main:\n    type: danubedata:SshKey\n    properties:\n      publicKey:\n        fn::readFile: ~/.ssh/id_ed25519.pub\n  web:\n    type: danubedata:Vps\n    properties:\n      image: ubuntu-22.04\n      datacenter: fsn1\n      authMethod: ssh_key\n      sshKeyId: ${main.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### VPS with Custom Resources\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as danubedata from \"@danubedata/pulumi\";\n\nconst app = new danubedata.Vps(\"app\", {\n    image: \"debian-12\",\n    datacenter: \"fsn1\",\n    authMethod: \"ssh_key\",\n    sshKeyId: danubedata_ssh_key.main.id,\n    cpuAllocationType: \"dedicated\",\n    cpuCores: 4,\n    memorySizeGb: 8,\n    storageSizeGb: 100,\n});\n```\n```python\nimport pulumi\nimport pulumi_danubedata as danubedata\n\napp = danubedata.Vps(\"app\",\n    image=\"debian-12\",\n    datacenter=\"fsn1\",\n    auth_method=\"ssh_key\",\n    ssh_key_id=danubedata_ssh_key[\"main\"][\"id\"],\n    cpu_allocation_type=\"dedicated\",\n    cpu_cores=4,\n    memory_size_gb=8,\n    storage_size_gb=100)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing DanubeData = DanubeData.DanubeData;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var app = new DanubeData.Vps(\"app\", new()\n    {\n        Image = \"debian-12\",\n        Datacenter = \"fsn1\",\n        AuthMethod = \"ssh_key\",\n        SshKeyId = danubedata_ssh_key.Main.Id,\n        CpuAllocationType = \"dedicated\",\n        CpuCores = 4,\n        MemorySizeGb = 8,\n        StorageSizeGb = 100,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/AdrianSilaghi/pulumi-danubedata/sdk/go/danubedata\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := danubedata.NewVps(ctx, \"app\", \u0026danubedata.VpsArgs{\n\t\t\tImage:             pulumi.String(\"debian-12\"),\n\t\t\tDatacenter:        pulumi.String(\"fsn1\"),\n\t\t\tAuthMethod:        pulumi.String(\"ssh_key\"),\n\t\t\tSshKeyId:          pulumi.Any(danubedata_ssh_key.Main.Id),\n\t\t\tCpuAllocationType: pulumi.String(\"dedicated\"),\n\t\t\tCpuCores:          pulumi.Int(4),\n\t\t\tMemorySizeGb:      pulumi.Int(8),\n\t\t\tStorageSizeGb:     pulumi.Int(100),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.danubedata.Vps;\nimport com.pulumi.danubedata.VpsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var app = new Vps(\"app\", VpsArgs.builder()\n            .image(\"debian-12\")\n            .datacenter(\"fsn1\")\n            .authMethod(\"ssh_key\")\n            .sshKeyId(danubedata_ssh_key.main().id())\n            .cpuAllocationType(\"dedicated\")\n            .cpuCores(4)\n            .memorySizeGb(8)\n            .storageSizeGb(100)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  app:\n    type: danubedata:Vps\n    properties:\n      image: debian-12\n      datacenter: fsn1\n      authMethod: ssh_key\n      sshKeyId: ${danubedata_ssh_key.main.id}\n      cpuAllocationType: dedicated\n      cpuCores: 4\n      memorySizeGb: 8\n      storageSizeGb: 100\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### VPS with Password Authentication\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as danubedata from \"@danubedata/pulumi\";\n\nconst dev = new danubedata.Vps(\"dev\", {\n    image: \"ubuntu-22.04\",\n    datacenter: \"fsn1\",\n    authMethod: \"password\",\n    password: _var.server_password,\n});\n```\n```python\nimport pulumi\nimport pulumi_danubedata as danubedata\n\ndev = danubedata.Vps(\"dev\",\n    image=\"ubuntu-22.04\",\n    datacenter=\"fsn1\",\n    auth_method=\"password\",\n    password=var[\"server_password\"])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing DanubeData = DanubeData.DanubeData;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var dev = new DanubeData.Vps(\"dev\", new()\n    {\n        Image = \"ubuntu-22.04\",\n        Datacenter = \"fsn1\",\n        AuthMethod = \"password\",\n        Password = @var.Server_password,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/AdrianSilaghi/pulumi-danubedata/sdk/go/danubedata\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := danubedata.NewVps(ctx, \"dev\", \u0026danubedata.VpsArgs{\n\t\t\tImage:      pulumi.String(\"ubuntu-22.04\"),\n\t\t\tDatacenter: pulumi.String(\"fsn1\"),\n\t\t\tAuthMethod: pulumi.String(\"password\"),\n\t\t\tPassword:   pulumi.Any(_var.Server_password),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.danubedata.Vps;\nimport com.pulumi.danubedata.VpsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var dev = new Vps(\"dev\", VpsArgs.builder()\n            .image(\"ubuntu-22.04\")\n            .datacenter(\"fsn1\")\n            .authMethod(\"password\")\n            .password(var_.server_password())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  dev:\n    type: danubedata:Vps\n    properties:\n      image: ubuntu-22.04\n      datacenter: fsn1\n      authMethod: password\n      password: ${var.server_password}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### VPS with Resource Profile\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as danubedata from \"@danubedata/pulumi\";\n\nconst standard = new danubedata.Vps(\"standard\", {\n    image: \"ubuntu-22.04\",\n    datacenter: \"fsn1\",\n    resourceProfile: \"vps-medium\",\n    authMethod: \"ssh_key\",\n    sshKeyId: danubedata_ssh_key.main.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_danubedata as danubedata\n\nstandard = danubedata.Vps(\"standard\",\n    image=\"ubuntu-22.04\",\n    datacenter=\"fsn1\",\n    resource_profile=\"vps-medium\",\n    auth_method=\"ssh_key\",\n    ssh_key_id=danubedata_ssh_key[\"main\"][\"id\"])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing DanubeData = DanubeData.DanubeData;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var standard = new DanubeData.Vps(\"standard\", new()\n    {\n        Image = \"ubuntu-22.04\",\n        Datacenter = \"fsn1\",\n        ResourceProfile = \"vps-medium\",\n        AuthMethod = \"ssh_key\",\n        SshKeyId = danubedata_ssh_key.Main.Id,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/AdrianSilaghi/pulumi-danubedata/sdk/go/danubedata\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := danubedata.NewVps(ctx, \"standard\", \u0026danubedata.VpsArgs{\n\t\t\tImage:           pulumi.String(\"ubuntu-22.04\"),\n\t\t\tDatacenter:      pulumi.String(\"fsn1\"),\n\t\t\tResourceProfile: pulumi.String(\"vps-medium\"),\n\t\t\tAuthMethod:      pulumi.String(\"ssh_key\"),\n\t\t\tSshKeyId:        pulumi.Any(danubedata_ssh_key.Main.Id),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.danubedata.Vps;\nimport com.pulumi.danubedata.VpsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var standard = new Vps(\"standard\", VpsArgs.builder()\n            .image(\"ubuntu-22.04\")\n            .datacenter(\"fsn1\")\n            .resourceProfile(\"vps-medium\")\n            .authMethod(\"ssh_key\")\n            .sshKeyId(danubedata_ssh_key.main().id())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  standard:\n    type: danubedata:Vps\n    properties:\n      image: ubuntu-22.04\n      datacenter: fsn1\n      resourceProfile: vps-medium\n      authMethod: ssh_key\n      sshKeyId: ${danubedata_ssh_key.main.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nVPS instances can be imported using their ID:\n\nbash\n\n```sh\n$ pulumi import danubedata:index/vps:Vps example vps-abc123\n```\n\n",
            "properties": {
                "authMethod": {
                    "type": "string",
                    "description": "Authentication method: 'ssh_key' or 'password'.\n"
                },
                "cpuAllocationType": {
                    "type": "string",
                    "description": "CPU allocation type: 'shared' or 'dedicated'.\n"
                },
                "cpuCores": {
                    "type": "integer",
                    "description": "Number of CPU cores. Can be specified during creation or update. VPS must be stopped to modify.\n"
                },
                "createdAt": {
                    "type": "string",
                    "description": "Creation timestamp.\n"
                },
                "customCloudInit": {
                    "type": "string",
                    "description": "Custom cloud-init configuration script.\n"
                },
                "datacenter": {
                    "type": "string",
                    "description": "Datacenter location (fsn1, nbg1, hel1, ash).\n"
                },
                "deployedAt": {
                    "type": "string",
                    "description": "Deployment timestamp.\n"
                },
                "image": {
                    "type": "string",
                    "description": "Operating system image (e.g., 'ubuntu-24.04', 'debian-12').\n"
                },
                "ipv6Address": {
                    "type": "string",
                    "description": "IPv6 address (if enabled).\n"
                },
                "memorySizeGb": {
                    "type": "integer",
                    "description": "Memory size in GB. Can be specified during creation or update. VPS must be stopped to modify.\n"
                },
                "monthlyCost": {
                    "type": "number",
                    "description": "Estimated monthly cost.\n"
                },
                "monthlyCostCents": {
                    "type": "integer",
                    "description": "Monthly cost in cents.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the VPS instance. Must be lowercase alphanumeric with hyphens.\n"
                },
                "networkStack": {
                    "type": "string",
                    "description": "Network stack: 'ipv4_only', 'ipv6_only', or 'dual_stack'.\n"
                },
                "password": {
                    "type": "string",
                    "description": "Root password (required if auth_method is 'password'). Must be at least 12 characters.\n",
                    "secret": true
                },
                "privateIp": {
                    "type": "string",
                    "description": "Private IP address.\n"
                },
                "publicIp": {
                    "type": "string",
                    "description": "Public IPv4 address.\n"
                },
                "resourceProfile": {
                    "type": "string",
                    "description": "Resource profile for the VPS (nano_shared, micro_shared, small_shared, medium_shared, large_shared, or dedicated\nvariants).\n"
                },
                "sshKeyId": {
                    "type": "string",
                    "description": "SSH key ID for authentication (required if auth_method is 'ssh_key').\n"
                },
                "status": {
                    "type": "string",
                    "description": "Current status of the VPS.\n"
                },
                "storageSizeGb": {
                    "type": "integer",
                    "description": "Storage size in GB. Can be specified during creation or update. VPS must be stopped to modify.\n"
                },
                "timeouts": {
                    "$ref": "#/types/danubedata:index/VpsTimeouts:VpsTimeouts"
                },
                "updatedAt": {
                    "type": "string",
                    "description": "Timestamp when the VPS was last updated.\n"
                }
            },
            "required": [
                "authMethod",
                "cpuAllocationType",
                "cpuCores",
                "createdAt",
                "datacenter",
                "deployedAt",
                "image",
                "ipv6Address",
                "memorySizeGb",
                "monthlyCost",
                "monthlyCostCents",
                "name",
                "networkStack",
                "privateIp",
                "publicIp",
                "resourceProfile",
                "status",
                "storageSizeGb",
                "updatedAt"
            ],
            "inputProperties": {
                "authMethod": {
                    "type": "string",
                    "description": "Authentication method: 'ssh_key' or 'password'.\n"
                },
                "cpuAllocationType": {
                    "type": "string",
                    "description": "CPU allocation type: 'shared' or 'dedicated'.\n"
                },
                "cpuCores": {
                    "type": "integer",
                    "description": "Number of CPU cores. Can be specified during creation or update. VPS must be stopped to modify.\n"
                },
                "customCloudInit": {
                    "type": "string",
                    "description": "Custom cloud-init configuration script.\n"
                },
                "datacenter": {
                    "type": "string",
                    "description": "Datacenter location (fsn1, nbg1, hel1, ash).\n"
                },
                "image": {
                    "type": "string",
                    "description": "Operating system image (e.g., 'ubuntu-24.04', 'debian-12').\n"
                },
                "memorySizeGb": {
                    "type": "integer",
                    "description": "Memory size in GB. Can be specified during creation or update. VPS must be stopped to modify.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the VPS instance. Must be lowercase alphanumeric with hyphens.\n"
                },
                "networkStack": {
                    "type": "string",
                    "description": "Network stack: 'ipv4_only', 'ipv6_only', or 'dual_stack'.\n"
                },
                "password": {
                    "type": "string",
                    "description": "Root password (required if auth_method is 'password'). Must be at least 12 characters.\n",
                    "secret": true
                },
                "resourceProfile": {
                    "type": "string",
                    "description": "Resource profile for the VPS (nano_shared, micro_shared, small_shared, medium_shared, large_shared, or dedicated\nvariants).\n"
                },
                "sshKeyId": {
                    "type": "string",
                    "description": "SSH key ID for authentication (required if auth_method is 'ssh_key').\n"
                },
                "storageSizeGb": {
                    "type": "integer",
                    "description": "Storage size in GB. Can be specified during creation or update. VPS must be stopped to modify.\n"
                },
                "timeouts": {
                    "$ref": "#/types/danubedata:index/VpsTimeouts:VpsTimeouts"
                }
            },
            "requiredInputs": [
                "authMethod",
                "datacenter",
                "image"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Vps resources.\n",
                "properties": {
                    "authMethod": {
                        "type": "string",
                        "description": "Authentication method: 'ssh_key' or 'password'.\n"
                    },
                    "cpuAllocationType": {
                        "type": "string",
                        "description": "CPU allocation type: 'shared' or 'dedicated'.\n"
                    },
                    "cpuCores": {
                        "type": "integer",
                        "description": "Number of CPU cores. Can be specified during creation or update. VPS must be stopped to modify.\n"
                    },
                    "createdAt": {
                        "type": "string",
                        "description": "Creation timestamp.\n"
                    },
                    "customCloudInit": {
                        "type": "string",
                        "description": "Custom cloud-init configuration script.\n"
                    },
                    "datacenter": {
                        "type": "string",
                        "description": "Datacenter location (fsn1, nbg1, hel1, ash).\n"
                    },
                    "deployedAt": {
                        "type": "string",
                        "description": "Deployment timestamp.\n"
                    },
                    "image": {
                        "type": "string",
                        "description": "Operating system image (e.g., 'ubuntu-24.04', 'debian-12').\n"
                    },
                    "ipv6Address": {
                        "type": "string",
                        "description": "IPv6 address (if enabled).\n"
                    },
                    "memorySizeGb": {
                        "type": "integer",
                        "description": "Memory size in GB. Can be specified during creation or update. VPS must be stopped to modify.\n"
                    },
                    "monthlyCost": {
                        "type": "number",
                        "description": "Estimated monthly cost.\n"
                    },
                    "monthlyCostCents": {
                        "type": "integer",
                        "description": "Monthly cost in cents.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the VPS instance. Must be lowercase alphanumeric with hyphens.\n"
                    },
                    "networkStack": {
                        "type": "string",
                        "description": "Network stack: 'ipv4_only', 'ipv6_only', or 'dual_stack'.\n"
                    },
                    "password": {
                        "type": "string",
                        "description": "Root password (required if auth_method is 'password'). Must be at least 12 characters.\n",
                        "secret": true
                    },
                    "privateIp": {
                        "type": "string",
                        "description": "Private IP address.\n"
                    },
                    "publicIp": {
                        "type": "string",
                        "description": "Public IPv4 address.\n"
                    },
                    "resourceProfile": {
                        "type": "string",
                        "description": "Resource profile for the VPS (nano_shared, micro_shared, small_shared, medium_shared, large_shared, or dedicated\nvariants).\n"
                    },
                    "sshKeyId": {
                        "type": "string",
                        "description": "SSH key ID for authentication (required if auth_method is 'ssh_key').\n"
                    },
                    "status": {
                        "type": "string",
                        "description": "Current status of the VPS.\n"
                    },
                    "storageSizeGb": {
                        "type": "integer",
                        "description": "Storage size in GB. Can be specified during creation or update. VPS must be stopped to modify.\n"
                    },
                    "timeouts": {
                        "$ref": "#/types/danubedata:index/VpsTimeouts:VpsTimeouts"
                    },
                    "updatedAt": {
                        "type": "string",
                        "description": "Timestamp when the VPS was last updated.\n"
                    }
                },
                "type": "object"
            }
        },
        "danubedata:index/vpsSnapshot:VpsSnapshot": {
            "description": "## # danubedata.VpsSnapshot\n\nManages a VPS snapshot for backup and recovery.\n\n## Example Usage\n\n### Basic Snapshot\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as danubedata from \"@danubedata/pulumi\";\n\nconst server = new danubedata.Vps(\"server\", {\n    image: \"ubuntu-22.04\",\n    datacenter: \"fsn1\",\n    authMethod: \"ssh_key\",\n    sshKeyId: danubedata_ssh_key.main.id,\n});\nconst backup = new danubedata.VpsSnapshot(\"backup\", {vpsInstanceId: server.id});\n```\n```python\nimport pulumi\nimport pulumi_danubedata as danubedata\n\nserver = danubedata.Vps(\"server\",\n    image=\"ubuntu-22.04\",\n    datacenter=\"fsn1\",\n    auth_method=\"ssh_key\",\n    ssh_key_id=danubedata_ssh_key[\"main\"][\"id\"])\nbackup = danubedata.VpsSnapshot(\"backup\", vps_instance_id=server.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing DanubeData = DanubeData.DanubeData;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var server = new DanubeData.Vps(\"server\", new()\n    {\n        Image = \"ubuntu-22.04\",\n        Datacenter = \"fsn1\",\n        AuthMethod = \"ssh_key\",\n        SshKeyId = danubedata_ssh_key.Main.Id,\n    });\n\n    var backup = new DanubeData.VpsSnapshot(\"backup\", new()\n    {\n        VpsInstanceId = server.Id,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/AdrianSilaghi/pulumi-danubedata/sdk/go/danubedata\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tserver, err := danubedata.NewVps(ctx, \"server\", \u0026danubedata.VpsArgs{\n\t\t\tImage:      pulumi.String(\"ubuntu-22.04\"),\n\t\t\tDatacenter: pulumi.String(\"fsn1\"),\n\t\t\tAuthMethod: pulumi.String(\"ssh_key\"),\n\t\t\tSshKeyId:   pulumi.Any(danubedata_ssh_key.Main.Id),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = danubedata.NewVpsSnapshot(ctx, \"backup\", \u0026danubedata.VpsSnapshotArgs{\n\t\t\tVpsInstanceId: server.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.danubedata.Vps;\nimport com.pulumi.danubedata.VpsArgs;\nimport com.pulumi.danubedata.VpsSnapshot;\nimport com.pulumi.danubedata.VpsSnapshotArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var server = new Vps(\"server\", VpsArgs.builder()\n            .image(\"ubuntu-22.04\")\n            .datacenter(\"fsn1\")\n            .authMethod(\"ssh_key\")\n            .sshKeyId(danubedata_ssh_key.main().id())\n            .build());\n\n        var backup = new VpsSnapshot(\"backup\", VpsSnapshotArgs.builder()\n            .vpsInstanceId(server.id())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  server:\n    type: danubedata:Vps\n    properties:\n      image: ubuntu-22.04\n      datacenter: fsn1\n      authMethod: ssh_key\n      sshKeyId: ${danubedata_ssh_key.main.id}\n  backup:\n    type: danubedata:VpsSnapshot\n    properties:\n      vpsInstanceId: ${server.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Snapshot with Description\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as danubedata from \"@danubedata/pulumi\";\n\nconst release = new danubedata.VpsSnapshot(\"release\", {\n    description: \"Snapshot before v1.0 release deployment\",\n    vpsInstanceId: danubedata_vps.server.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_danubedata as danubedata\n\nrelease = danubedata.VpsSnapshot(\"release\",\n    description=\"Snapshot before v1.0 release deployment\",\n    vps_instance_id=danubedata_vps[\"server\"][\"id\"])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing DanubeData = DanubeData.DanubeData;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var release = new DanubeData.VpsSnapshot(\"release\", new()\n    {\n        Description = \"Snapshot before v1.0 release deployment\",\n        VpsInstanceId = danubedata_vps.Server.Id,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/AdrianSilaghi/pulumi-danubedata/sdk/go/danubedata\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := danubedata.NewVpsSnapshot(ctx, \"release\", \u0026danubedata.VpsSnapshotArgs{\n\t\t\tDescription:   pulumi.String(\"Snapshot before v1.0 release deployment\"),\n\t\t\tVpsInstanceId: pulumi.Any(danubedata_vps.Server.Id),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.danubedata.VpsSnapshot;\nimport com.pulumi.danubedata.VpsSnapshotArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var release = new VpsSnapshot(\"release\", VpsSnapshotArgs.builder()\n            .description(\"Snapshot before v1.0 release deployment\")\n            .vpsInstanceId(danubedata_vps.server().id())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  release:\n    type: danubedata:VpsSnapshot\n    properties:\n      description: Snapshot before v1.0 release deployment\n      vpsInstanceId: ${danubedata_vps.server.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nVPS snapshots can be imported using their ID:\n\nbash\n\n```sh\n$ pulumi import danubedata:index/vpsSnapshot:VpsSnapshot example snap-abc123\n```\n\n",
            "properties": {
                "createdAt": {
                    "type": "string",
                    "description": "Creation timestamp.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Description of the snapshot.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the snapshot.\n"
                },
                "sizeGb": {
                    "type": "number",
                    "description": "Size of the snapshot in GB.\n"
                },
                "status": {
                    "type": "string",
                    "description": "Current status (`creating`, `ready`, `error`).\n"
                },
                "timeouts": {
                    "$ref": "#/types/danubedata:index/VpsSnapshotTimeouts:VpsSnapshotTimeouts"
                },
                "updatedAt": {
                    "type": "string",
                    "description": "Timestamp when the snapshot was last updated.\n"
                },
                "vpsInstanceId": {
                    "type": "string",
                    "description": "ID of the VPS instance to snapshot.\n"
                }
            },
            "required": [
                "createdAt",
                "name",
                "sizeGb",
                "status",
                "updatedAt",
                "vpsInstanceId"
            ],
            "inputProperties": {
                "description": {
                    "type": "string",
                    "description": "Description of the snapshot.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the snapshot.\n"
                },
                "timeouts": {
                    "$ref": "#/types/danubedata:index/VpsSnapshotTimeouts:VpsSnapshotTimeouts"
                },
                "vpsInstanceId": {
                    "type": "string",
                    "description": "ID of the VPS instance to snapshot.\n"
                }
            },
            "requiredInputs": [
                "vpsInstanceId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering VpsSnapshot resources.\n",
                "properties": {
                    "createdAt": {
                        "type": "string",
                        "description": "Creation timestamp.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "Description of the snapshot.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the snapshot.\n"
                    },
                    "sizeGb": {
                        "type": "number",
                        "description": "Size of the snapshot in GB.\n"
                    },
                    "status": {
                        "type": "string",
                        "description": "Current status (`creating`, `ready`, `error`).\n"
                    },
                    "timeouts": {
                        "$ref": "#/types/danubedata:index/VpsSnapshotTimeouts:VpsSnapshotTimeouts"
                    },
                    "updatedAt": {
                        "type": "string",
                        "description": "Timestamp when the snapshot was last updated.\n"
                    },
                    "vpsInstanceId": {
                        "type": "string",
                        "description": "ID of the VPS instance to snapshot.\n"
                    }
                },
                "type": "object"
            }
        }
    },
    "functions": {
        "danubedata:index/getCacheProviders:getCacheProviders": {
            "description": "## # danubedata.getCacheProviders\n\nLists available cache providers (Redis, Valkey, Dragonfly).\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as danubedata from \"@pulumi/danubedata\";\n\nconst all = danubedata.getCacheProviders({});\nexport const cacheProviders = all.then(all =\u003e .map(p =\u003e ({\n    id: p.id,\n    name: p.name,\n})));\n```\n```python\nimport pulumi\nimport pulumi_danubedata as danubedata\n\nall = danubedata.get_cache_providers()\npulumi.export(\"cacheProviders\", [{\n    \"id\": p.id,\n    \"name\": p.name,\n} for p in all.providers])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing DanubeData = Pulumi.DanubeData;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var all = DanubeData.GetCacheProviders.Invoke();\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"cacheProviders\"] = .Select(p =\u003e \n        {\n            return \n            {\n                { \"id\", p.Id },\n                { \"name\", p.Name },\n            };\n        }).ToList(),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/AdrianSilaghi/pulumi-danubedata/sdk/go/danubedata\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tall, err := danubedata.GetCacheProviders(ctx, map[string]interface{}{}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"cacheProviders\", pulumi.MapArray(\"TODO: For expression\"))\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.danubedata.DanubedataFunctions;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var all = DanubedataFunctions.getCacheProviders();\n\n        ctx.export(\"cacheProviders\", \"TODO: ForExpression\");\n    }\n}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n",
            "outputs": {
                "description": "A collection of values returned by getCacheProviders.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "providers": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/danubedata:index/getCacheProvidersProvider:getCacheProvidersProvider"
                        },
                        "description": "List of cache providers. Each provider contains:\n"
                    }
                },
                "type": "object",
                "required": [
                    "providers",
                    "id"
                ]
            }
        },
        "danubedata:index/getCaches:getCaches": {
            "description": "## # danubedata.getCaches\n\nLists all cache instances in your account.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as danubedata from \"@pulumi/danubedata\";\n\nconst all = danubedata.getCaches({});\nexport const cacheCount = all.then(all =\u003e all.instances).length;\nexport const cacheEndpoints = all.then(all =\u003e .reduce((__obj, cache) =\u003e ({ ...__obj, [cache.name]: `${cache.endpoint}:${cache.port}` })));\n```\n```python\nimport pulumi\nimport pulumi_danubedata as danubedata\n\nall = danubedata.get_caches()\npulumi.export(\"cacheCount\", len(all.instances))\npulumi.export(\"cacheEndpoints\", {cache.name: f\"{cache.endpoint}:{cache.port}\" for cache in all.instances})\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing DanubeData = Pulumi.DanubeData;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var all = DanubeData.GetCaches.Invoke();\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"cacheCount\"] = all.Apply(getCachesResult =\u003e getCachesResult.Instances).Length,\n        [\"cacheEndpoints\"] = .ToDictionary(item =\u003e {\n            var cache = item.Value;\n            return cache.Name;\n        }, item =\u003e {\n            var cache = item.Value;\n            return $\"{cache.Endpoint}:{cache.Port}\";\n        }),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/AdrianSilaghi/pulumi-danubedata/sdk/go/danubedata\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tall, err := danubedata.GetCaches(ctx, map[string]interface{}{}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"cacheCount\", pulumi.Int(len(all.Instances)))\n\t\tctx.Export(\"cacheEndpoints\", pulumi.StringMap(\"TODO: For expression\"))\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.danubedata.DanubedataFunctions;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var all = DanubedataFunctions.getCaches();\n\n        ctx.export(\"cacheCount\", all.applyValue(getCachesResult -\u003e getCachesResult.instances()).length());\n        ctx.export(\"cacheEndpoints\", \"TODO: ForExpression\");\n    }\n}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Find Cache by Name\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as danubedata from \"@pulumi/danubedata\";\n\nconst all = danubedata.getCaches({});\nconst mainCache = all.then(all =\u003e .filter(c =\u003e c.name == \"main-cache\").map(c =\u003e (c))[0]);\nexport const redisUrl = `redis://${mainCache.endpoint}:${mainCache.port}`;\n```\n```python\nimport pulumi\nimport pulumi_danubedata as danubedata\n\nall = danubedata.get_caches()\nmain_cache = [c for c in all.instances if c.name == \"main-cache\"][0]\npulumi.export(\"redisUrl\", f\"redis://{main_cache.endpoint}:{main_cache.port}\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing DanubeData = Pulumi.DanubeData;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var all = DanubeData.GetCaches.Invoke();\n\n    var mainCache = .Where(c =\u003e c.Name == \"main-cache\").Select(c =\u003e \n    {\n        return c;\n    }).ToList()[0];\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"redisUrl\"] = $\"redis://{mainCache.Endpoint}:{mainCache.Port}\",\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/AdrianSilaghi/pulumi-danubedata/sdk/go/danubedata\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tall, err := danubedata.GetCaches(ctx, map[string]interface{}{}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tmainCache := \"TODO: For expression\"[0]\n\t\tctx.Export(\"redisUrl\", pulumi.Sprintf(\"redis://%v:%v\", mainCache.Endpoint, mainCache.Port))\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.danubedata.DanubedataFunctions;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var all = DanubedataFunctions.getCaches();\n\n        final var mainCache = \"TODO: ForExpression\"[0];\n\n        ctx.export(\"redisUrl\", String.format(\"redis://%s:%s\", mainCache.endpoint(),mainCache.port()));\n    }\n}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Filter by Provider\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as danubedata from \"@pulumi/danubedata\";\n\nconst all = danubedata.getCaches({});\nconst redisCaches = all.then(all =\u003e .filter(c =\u003e c.cacheProvider == \"Redis\").map(c =\u003e (c)));\nconst dragonflyCaches = all.then(all =\u003e .filter(c =\u003e c.cacheProvider == \"Dragonfly\").map(c =\u003e (c)));\nexport const redisCount = redisCaches.length;\n```\n```python\nimport pulumi\nimport pulumi_danubedata as danubedata\n\nall = danubedata.get_caches()\nredis_caches = [c for c in all.instances if c.cache_provider == \"Redis\"]\ndragonfly_caches = [c for c in all.instances if c.cache_provider == \"Dragonfly\"]\npulumi.export(\"redisCount\", len(redis_caches))\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing DanubeData = Pulumi.DanubeData;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var all = DanubeData.GetCaches.Invoke();\n\n    var redisCaches = .Where(c =\u003e c.CacheProvider == \"Redis\").Select(c =\u003e \n    {\n        return c;\n    }).ToList();\n\n    var dragonflyCaches = .Where(c =\u003e c.CacheProvider == \"Dragonfly\").Select(c =\u003e \n    {\n        return c;\n    }).ToList();\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"redisCount\"] = redisCaches.Length,\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/AdrianSilaghi/pulumi-danubedata/sdk/go/danubedata\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tall, err := danubedata.GetCaches(ctx, map[string]interface{}{}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tredisCaches := \"TODO: For expression\"\n\t\t_ := \"TODO: For expression\"\n\t\tctx.Export(\"redisCount\", pulumi.Int(len(redisCaches)))\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.danubedata.DanubedataFunctions;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var all = DanubedataFunctions.getCaches();\n\n        final var redisCaches = \"TODO: ForExpression\";\n\n        final var dragonflyCaches = \"TODO: ForExpression\";\n\n        ctx.export(\"redisCount\", redisCaches.length());\n    }\n}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "outputs": {
                "description": "A collection of values returned by getCaches.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "instances": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/danubedata:index/getCachesInstance:getCachesInstance"
                        },
                        "description": "List of cache instances. Each instance contains:\n"
                    }
                },
                "type": "object",
                "required": [
                    "instances",
                    "id"
                ]
            }
        },
        "danubedata:index/getDatabaseProviders:getDatabaseProviders": {
            "description": "## # danubedata.getDatabaseProviders\n\nLists available database providers (MySQL, PostgreSQL, MariaDB).\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as danubedata from \"@pulumi/danubedata\";\n\nconst all = danubedata.getDatabaseProviders({});\nexport const databaseProviders = all.then(all =\u003e .map(p =\u003e ({\n    id: p.id,\n    name: p.name,\n})));\n```\n```python\nimport pulumi\nimport pulumi_danubedata as danubedata\n\nall = danubedata.get_database_providers()\npulumi.export(\"databaseProviders\", [{\n    \"id\": p.id,\n    \"name\": p.name,\n} for p in all.providers])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing DanubeData = Pulumi.DanubeData;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var all = DanubeData.GetDatabaseProviders.Invoke();\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"databaseProviders\"] = .Select(p =\u003e \n        {\n            return \n            {\n                { \"id\", p.Id },\n                { \"name\", p.Name },\n            };\n        }).ToList(),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/AdrianSilaghi/pulumi-danubedata/sdk/go/danubedata\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tall, err := danubedata.GetDatabaseProviders(ctx, map[string]interface{}{}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"databaseProviders\", pulumi.MapArray(\"TODO: For expression\"))\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.danubedata.DanubedataFunctions;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var all = DanubedataFunctions.getDatabaseProviders();\n\n        ctx.export(\"databaseProviders\", \"TODO: ForExpression\");\n    }\n}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n",
            "outputs": {
                "description": "A collection of values returned by getDatabaseProviders.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "providers": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/danubedata:index/getDatabaseProvidersProvider:getDatabaseProvidersProvider"
                        },
                        "description": "List of database providers. Each provider contains:\n"
                    }
                },
                "type": "object",
                "required": [
                    "providers",
                    "id"
                ]
            }
        },
        "danubedata:index/getDatabases:getDatabases": {
            "description": "## # danubedata.getDatabases\n\nLists all database instances in your account.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as danubedata from \"@pulumi/danubedata\";\n\nconst all = danubedata.getDatabases({});\nexport const databaseCount = all.then(all =\u003e all.instances).length;\nexport const databaseEndpoints = all.then(all =\u003e .reduce((__obj, db) =\u003e ({ ...__obj, [db.name]: db.endpoint })));\n```\n```python\nimport pulumi\nimport pulumi_danubedata as danubedata\n\nall = danubedata.get_databases()\npulumi.export(\"databaseCount\", len(all.instances))\npulumi.export(\"databaseEndpoints\", {db.name: db.endpoint for db in all.instances})\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing DanubeData = Pulumi.DanubeData;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var all = DanubeData.GetDatabases.Invoke();\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"databaseCount\"] = all.Apply(getDatabasesResult =\u003e getDatabasesResult.Instances).Length,\n        [\"databaseEndpoints\"] = .ToDictionary(item =\u003e {\n            var db = item.Value;\n            return db.Name;\n        }, item =\u003e {\n            var db = item.Value;\n            return db.Endpoint;\n        }),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/AdrianSilaghi/pulumi-danubedata/sdk/go/danubedata\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tall, err := danubedata.GetDatabases(ctx, map[string]interface{}{}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"databaseCount\", pulumi.Int(len(all.Instances)))\n\t\tctx.Export(\"databaseEndpoints\", pulumi.StringMap(\"TODO: For expression\"))\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.danubedata.DanubedataFunctions;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var all = DanubedataFunctions.getDatabases();\n\n        ctx.export(\"databaseCount\", all.applyValue(getDatabasesResult -\u003e getDatabasesResult.instances()).length());\n        ctx.export(\"databaseEndpoints\", \"TODO: ForExpression\");\n    }\n}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Find Database by Name\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as danubedata from \"@pulumi/danubedata\";\n\nconst all = danubedata.getDatabases({});\nconst productionDb = all.then(all =\u003e .filter(db =\u003e db.name == \"production-db\").map(db =\u003e (db))[0]);\nexport const productionConnection = `${productionDb.engine}://${productionDb.username}@${productionDb.endpoint}:${productionDb.port}/${productionDb.databaseName}`;\n```\n```python\nimport pulumi\nimport pulumi_danubedata as danubedata\n\nall = danubedata.get_databases()\nproduction_db = [db for db in all.instances if db.name == \"production-db\"][0]\npulumi.export(\"productionConnection\", f\"{production_db.engine}://{production_db.username}@{production_db.endpoint}:{production_db.port}/{production_db.database_name}\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing DanubeData = Pulumi.DanubeData;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var all = DanubeData.GetDatabases.Invoke();\n\n    var productionDb = .Where(db =\u003e db.Name == \"production-db\").Select(db =\u003e \n    {\n        return db;\n    }).ToList()[0];\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"productionConnection\"] = $\"{productionDb.Engine}://{productionDb.Username}@{productionDb.Endpoint}:{productionDb.Port}/{productionDb.DatabaseName}\",\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/AdrianSilaghi/pulumi-danubedata/sdk/go/danubedata\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tall, err := danubedata.GetDatabases(ctx, map[string]interface{}{}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tproductionDb := \"TODO: For expression\"[0]\n\t\tctx.Export(\"productionConnection\", pulumi.Sprintf(\"%v://%v@%v:%v/%v\", productionDb.Engine, productionDb.Username, productionDb.Endpoint, productionDb.Port, productionDb.DatabaseName))\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.danubedata.DanubedataFunctions;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var all = DanubedataFunctions.getDatabases();\n\n        final var productionDb = \"TODO: ForExpression\"[0];\n\n        ctx.export(\"productionConnection\", String.format(\"%s://%s@%s:%s/%s\", productionDb.engine(),productionDb.username(),productionDb.endpoint(),productionDb.port(),productionDb.databaseName()));\n    }\n}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Filter by Engine\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as danubedata from \"@pulumi/danubedata\";\n\nconst all = danubedata.getDatabases({});\nconst postgresDbs = all.then(all =\u003e .filter(db =\u003e db.engine == \"PostgreSQL\").map(db =\u003e (db)));\nconst mysqlDbs = all.then(all =\u003e .filter(db =\u003e db.engine == \"MySQL\").map(db =\u003e (db)));\nexport const postgresCount = postgresDbs.length;\n```\n```python\nimport pulumi\nimport pulumi_danubedata as danubedata\n\nall = danubedata.get_databases()\npostgres_dbs = [db for db in all.instances if db.engine == \"PostgreSQL\"]\nmysql_dbs = [db for db in all.instances if db.engine == \"MySQL\"]\npulumi.export(\"postgresCount\", len(postgres_dbs))\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing DanubeData = Pulumi.DanubeData;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var all = DanubeData.GetDatabases.Invoke();\n\n    var postgresDbs = .Where(db =\u003e db.Engine == \"PostgreSQL\").Select(db =\u003e \n    {\n        return db;\n    }).ToList();\n\n    var mysqlDbs = .Where(db =\u003e db.Engine == \"MySQL\").Select(db =\u003e \n    {\n        return db;\n    }).ToList();\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"postgresCount\"] = postgresDbs.Length,\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/AdrianSilaghi/pulumi-danubedata/sdk/go/danubedata\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tall, err := danubedata.GetDatabases(ctx, map[string]interface{}{}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tpostgresDbs := \"TODO: For expression\"\n\t\t_ := \"TODO: For expression\"\n\t\tctx.Export(\"postgresCount\", pulumi.Int(len(postgresDbs)))\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.danubedata.DanubedataFunctions;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var all = DanubedataFunctions.getDatabases();\n\n        final var postgresDbs = \"TODO: ForExpression\";\n\n        final var mysqlDbs = \"TODO: ForExpression\";\n\n        ctx.export(\"postgresCount\", postgresDbs.length());\n    }\n}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "outputs": {
                "description": "A collection of values returned by getDatabases.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "instances": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/danubedata:index/getDatabasesInstance:getDatabasesInstance"
                        },
                        "description": "List of database instances. Each instance contains:\n"
                    }
                },
                "type": "object",
                "required": [
                    "instances",
                    "id"
                ]
            }
        },
        "danubedata:index/getFirewalls:getFirewalls": {
            "description": "## # danubedata.getFirewalls\n\nLists all firewalls in your account.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as danubedata from \"@pulumi/danubedata\";\n\nconst all = danubedata.getFirewalls({});\nexport const firewallCount = all.then(all =\u003e all.firewalls).length;\nexport const firewallNames = all.then(all =\u003e .map(fw =\u003e (fw.name)));\n```\n```python\nimport pulumi\nimport pulumi_danubedata as danubedata\n\nall = danubedata.get_firewalls()\npulumi.export(\"firewallCount\", len(all.firewalls))\npulumi.export(\"firewallNames\", [fw.name for fw in all.firewalls])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing DanubeData = Pulumi.DanubeData;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var all = DanubeData.GetFirewalls.Invoke();\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"firewallCount\"] = all.Apply(getFirewallsResult =\u003e getFirewallsResult.Firewalls).Length,\n        [\"firewallNames\"] = .Select(fw =\u003e \n        {\n            return fw.Name;\n        }).ToList(),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/AdrianSilaghi/pulumi-danubedata/sdk/go/danubedata\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tall, err := danubedata.GetFirewalls(ctx, map[string]interface{}{}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"firewallCount\", pulumi.Int(len(all.Firewalls)))\n\t\tctx.Export(\"firewallNames\", pulumi.StringArray(\"TODO: For expression\"))\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.danubedata.DanubedataFunctions;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var all = DanubedataFunctions.getFirewalls();\n\n        ctx.export(\"firewallCount\", all.applyValue(getFirewallsResult -\u003e getFirewallsResult.firewalls()).length());\n        ctx.export(\"firewallNames\", \"TODO: ForExpression\");\n    }\n}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Find Firewall by Name\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as danubedata from \"@pulumi/danubedata\";\n\nconst all = danubedata.getFirewalls({});\nconst webFirewall = all.then(all =\u003e .filter(fw =\u003e fw.name == \"web-firewall\").map(fw =\u003e (fw))[0]);\nexport const webFirewallId = webFirewall.id;\nexport const webFirewallRules = webFirewall.rulesCount;\n```\n```python\nimport pulumi\nimport pulumi_danubedata as danubedata\n\nall = danubedata.get_firewalls()\nweb_firewall = [fw for fw in all.firewalls if fw.name == \"web-firewall\"][0]\npulumi.export(\"webFirewallId\", web_firewall.id)\npulumi.export(\"webFirewallRules\", web_firewall.rules_count)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing DanubeData = Pulumi.DanubeData;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var all = DanubeData.GetFirewalls.Invoke();\n\n    var webFirewall = .Where(fw =\u003e fw.Name == \"web-firewall\").Select(fw =\u003e \n    {\n        return fw;\n    }).ToList()[0];\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"webFirewallId\"] = webFirewall.Id,\n        [\"webFirewallRules\"] = webFirewall.RulesCount,\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/AdrianSilaghi/pulumi-danubedata/sdk/go/danubedata\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tall, err := danubedata.GetFirewalls(ctx, map[string]interface{}{}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\twebFirewall := \"TODO: For expression\"[0]\n\t\tctx.Export(\"webFirewallId\", webFirewall.Id)\n\t\tctx.Export(\"webFirewallRules\", webFirewall.RulesCount)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.danubedata.DanubedataFunctions;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var all = DanubedataFunctions.getFirewalls();\n\n        final var webFirewall = \"TODO: ForExpression\"[0];\n\n        ctx.export(\"webFirewallId\", webFirewall.id());\n        ctx.export(\"webFirewallRules\", webFirewall.rulesCount());\n    }\n}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Find Default Firewall\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as danubedata from \"@pulumi/danubedata\";\n\nconst all = danubedata.getFirewalls({});\nconst defaultFirewall = all.then(all =\u003e .filter(fw =\u003e fw.isDefault).map(fw =\u003e (fw))[0]);\nexport const defaultFirewallId = defaultFirewall.id;\n```\n```python\nimport pulumi\nimport pulumi_danubedata as danubedata\n\nall = danubedata.get_firewalls()\ndefault_firewall = [fw for fw in all.firewalls if fw.is_default][0]\npulumi.export(\"defaultFirewallId\", default_firewall.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing DanubeData = Pulumi.DanubeData;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var all = DanubeData.GetFirewalls.Invoke();\n\n    var defaultFirewall = .Where(fw =\u003e fw.IsDefault).Select(fw =\u003e \n    {\n        return fw;\n    }).ToList()[0];\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"defaultFirewallId\"] = defaultFirewall.Id,\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/AdrianSilaghi/pulumi-danubedata/sdk/go/danubedata\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tall, err := danubedata.GetFirewalls(ctx, map[string]interface{}{}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdefaultFirewall := \"TODO: For expression\"[0]\n\t\tctx.Export(\"defaultFirewallId\", defaultFirewall.Id)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.danubedata.DanubedataFunctions;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var all = DanubedataFunctions.getFirewalls();\n\n        final var defaultFirewall = \"TODO: ForExpression\"[0];\n\n        ctx.export(\"defaultFirewallId\", defaultFirewall.id());\n    }\n}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "outputs": {
                "description": "A collection of values returned by getFirewalls.\n",
                "properties": {
                    "firewalls": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/danubedata:index/getFirewallsFirewall:getFirewallsFirewall"
                        },
                        "description": "List of firewalls. Each firewall contains:\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    }
                },
                "type": "object",
                "required": [
                    "firewalls",
                    "id"
                ]
            }
        },
        "danubedata:index/getServerlessContainers:getServerlessContainers": {
            "description": "## # danubedata.getServerlessContainers\n\nLists all serverless containers in your account.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as danubedata from \"@pulumi/danubedata\";\n\nconst all = danubedata.getServerlessContainers({});\nexport const containerCount = all.then(all =\u003e all.containers).length;\nexport const containerUrls = all.then(all =\u003e .reduce((__obj, c) =\u003e ({ ...__obj, [c.name]: c.url })));\n```\n```python\nimport pulumi\nimport pulumi_danubedata as danubedata\n\nall = danubedata.get_serverless_containers()\npulumi.export(\"containerCount\", len(all.containers))\npulumi.export(\"containerUrls\", {c.name: c.url for c in all.containers})\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing DanubeData = Pulumi.DanubeData;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var all = DanubeData.GetServerlessContainers.Invoke();\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"containerCount\"] = all.Apply(getServerlessContainersResult =\u003e getServerlessContainersResult.Containers).Length,\n        [\"containerUrls\"] = .ToDictionary(item =\u003e {\n            var c = item.Value;\n            return c.Name;\n        }, item =\u003e {\n            var c = item.Value;\n            return c.Url;\n        }),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/AdrianSilaghi/pulumi-danubedata/sdk/go/danubedata\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tall, err := danubedata.GetServerlessContainers(ctx, map[string]interface{}{}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"containerCount\", pulumi.Int(len(all.Containers)))\n\t\tctx.Export(\"containerUrls\", pulumi.StringMap(\"TODO: For expression\"))\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.danubedata.DanubedataFunctions;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var all = DanubedataFunctions.getServerlessContainers();\n\n        ctx.export(\"containerCount\", all.applyValue(getServerlessContainersResult -\u003e getServerlessContainersResult.containers()).length());\n        ctx.export(\"containerUrls\", \"TODO: ForExpression\");\n    }\n}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Find Container by Name\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as danubedata from \"@pulumi/danubedata\";\n\nconst all = danubedata.getServerlessContainers({});\nconst apiContainer = all.then(all =\u003e .filter(c =\u003e c.name == \"api-server\").map(c =\u003e (c))[0]);\nexport const apiUrl = apiContainer.url;\nexport const apiStatus = apiContainer.status;\n```\n```python\nimport pulumi\nimport pulumi_danubedata as danubedata\n\nall = danubedata.get_serverless_containers()\napi_container = [c for c in all.containers if c.name == \"api-server\"][0]\npulumi.export(\"apiUrl\", api_container.url)\npulumi.export(\"apiStatus\", api_container.status)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing DanubeData = Pulumi.DanubeData;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var all = DanubeData.GetServerlessContainers.Invoke();\n\n    var apiContainer = .Where(c =\u003e c.Name == \"api-server\").Select(c =\u003e \n    {\n        return c;\n    }).ToList()[0];\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"apiUrl\"] = apiContainer.Url,\n        [\"apiStatus\"] = apiContainer.Status,\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/AdrianSilaghi/pulumi-danubedata/sdk/go/danubedata\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tall, err := danubedata.GetServerlessContainers(ctx, map[string]interface{}{}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tapiContainer := \"TODO: For expression\"[0]\n\t\tctx.Export(\"apiUrl\", apiContainer.Url)\n\t\tctx.Export(\"apiStatus\", apiContainer.Status)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.danubedata.DanubedataFunctions;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var all = DanubedataFunctions.getServerlessContainers();\n\n        final var apiContainer = \"TODO: ForExpression\"[0];\n\n        ctx.export(\"apiUrl\", apiContainer.url());\n        ctx.export(\"apiStatus\", apiContainer.status());\n    }\n}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Filter by Deployment Type\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as danubedata from \"@pulumi/danubedata\";\n\nconst all = danubedata.getServerlessContainers({});\nconst dockerContainers = all.then(all =\u003e .filter(c =\u003e c.deploymentType == \"docker\").map(c =\u003e (c)));\nconst gitContainers = all.then(all =\u003e .filter(c =\u003e c.deploymentType == \"git\").map(c =\u003e (c)));\nexport const dockerCount = dockerContainers.length;\n```\n```python\nimport pulumi\nimport pulumi_danubedata as danubedata\n\nall = danubedata.get_serverless_containers()\ndocker_containers = [c for c in all.containers if c.deployment_type == \"docker\"]\ngit_containers = [c for c in all.containers if c.deployment_type == \"git\"]\npulumi.export(\"dockerCount\", len(docker_containers))\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing DanubeData = Pulumi.DanubeData;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var all = DanubeData.GetServerlessContainers.Invoke();\n\n    var dockerContainers = .Where(c =\u003e c.DeploymentType == \"docker\").Select(c =\u003e \n    {\n        return c;\n    }).ToList();\n\n    var gitContainers = .Where(c =\u003e c.DeploymentType == \"git\").Select(c =\u003e \n    {\n        return c;\n    }).ToList();\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"dockerCount\"] = dockerContainers.Length,\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/AdrianSilaghi/pulumi-danubedata/sdk/go/danubedata\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tall, err := danubedata.GetServerlessContainers(ctx, map[string]interface{}{}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdockerContainers := \"TODO: For expression\"\n\t\t_ := \"TODO: For expression\"\n\t\tctx.Export(\"dockerCount\", pulumi.Int(len(dockerContainers)))\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.danubedata.DanubedataFunctions;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var all = DanubedataFunctions.getServerlessContainers();\n\n        final var dockerContainers = \"TODO: ForExpression\";\n\n        final var gitContainers = \"TODO: ForExpression\";\n\n        ctx.export(\"dockerCount\", dockerContainers.length());\n    }\n}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "outputs": {
                "description": "A collection of values returned by getServerlessContainers.\n",
                "properties": {
                    "containers": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/danubedata:index/getServerlessContainersContainer:getServerlessContainersContainer"
                        },
                        "description": "List of serverless containers. Each container contains:\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    }
                },
                "type": "object",
                "required": [
                    "containers",
                    "id"
                ]
            }
        },
        "danubedata:index/getSshKeys:getSshKeys": {
            "description": "## # danubedata.getSshKeys\n\nLists all SSH keys in your account.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as danubedata from \"@pulumi/danubedata\";\n\nconst all = danubedata.getSshKeys({});\nexport const sshKeyIds = all.then(all =\u003e .map(key =\u003e (key.id)));\nexport const sshKeyNames = all.then(all =\u003e .map(key =\u003e (key.name)));\n```\n```python\nimport pulumi\nimport pulumi_danubedata as danubedata\n\nall = danubedata.get_ssh_keys()\npulumi.export(\"sshKeyIds\", [key.id for key in all.keys])\npulumi.export(\"sshKeyNames\", [key.name for key in all.keys])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing DanubeData = Pulumi.DanubeData;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var all = DanubeData.GetSshKeys.Invoke();\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"sshKeyIds\"] = .Select(key =\u003e \n        {\n            return key.Id;\n        }).ToList(),\n        [\"sshKeyNames\"] = .Select(key =\u003e \n        {\n            return key.Name;\n        }).ToList(),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/AdrianSilaghi/pulumi-danubedata/sdk/go/danubedata\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tall, err := danubedata.GetSshKeys(ctx, map[string]interface{}{}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"sshKeyIds\", pulumi.StringArray(\"TODO: For expression\"))\n\t\tctx.Export(\"sshKeyNames\", pulumi.StringArray(\"TODO: For expression\"))\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.danubedata.DanubedataFunctions;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var all = DanubedataFunctions.getSshKeys();\n\n        ctx.export(\"sshKeyIds\", \"TODO: ForExpression\");\n        ctx.export(\"sshKeyNames\", \"TODO: ForExpression\");\n    }\n}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Find Key by Name\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as danubedata from \"@danubedata/pulumi\";\nimport * as danubedata from \"@pulumi/danubedata\";\n\nconst all = danubedata.getSshKeys({});\nconst deployKey = all.then(all =\u003e .filter(key =\u003e key.name == \"deploy-key\").map(key =\u003e (key))[0]);\nconst server = new danubedata.Vps(\"server\", {\n    image: \"ubuntu-22.04\",\n    datacenter: \"fsn1\",\n    authMethod: \"ssh_key\",\n    sshKeyId: deployKey.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_danubedata as danubedata\n\nall = danubedata.get_ssh_keys()\ndeploy_key = [key for key in all.keys if key.name == \"deploy-key\"][0]\nserver = danubedata.Vps(\"server\",\n    image=\"ubuntu-22.04\",\n    datacenter=\"fsn1\",\n    auth_method=\"ssh_key\",\n    ssh_key_id=deploy_key.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing DanubeData = DanubeData.DanubeData;\nusing DanubeData = Pulumi.DanubeData;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var all = DanubeData.GetSshKeys.Invoke();\n\n    var deployKey = .Where(key =\u003e key.Name == \"deploy-key\").Select(key =\u003e \n    {\n        return key;\n    }).ToList()[0];\n\n    var server = new DanubeData.Vps(\"server\", new()\n    {\n        Image = \"ubuntu-22.04\",\n        Datacenter = \"fsn1\",\n        AuthMethod = \"ssh_key\",\n        SshKeyId = deployKey.Id,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/AdrianSilaghi/pulumi-danubedata/sdk/go/danubedata\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tall, err := danubedata.GetSshKeys(ctx, map[string]interface{}{}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdeployKey := \"TODO: For expression\"[0]\n\t\t_, err = danubedata.NewVps(ctx, \"server\", \u0026danubedata.VpsArgs{\n\t\t\tImage:      pulumi.String(\"ubuntu-22.04\"),\n\t\t\tDatacenter: pulumi.String(\"fsn1\"),\n\t\t\tAuthMethod: pulumi.String(\"ssh_key\"),\n\t\t\tSshKeyId:   pulumi.String(deployKey.Id),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.danubedata.DanubedataFunctions;\nimport com.pulumi.danubedata.Vps;\nimport com.pulumi.danubedata.VpsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var all = DanubedataFunctions.getSshKeys();\n\n        final var deployKey = \"TODO: ForExpression\"[0];\n\n        var server = new Vps(\"server\", VpsArgs.builder()\n            .image(\"ubuntu-22.04\")\n            .datacenter(\"fsn1\")\n            .authMethod(\"ssh_key\")\n            .sshKeyId(deployKey.id())\n            .build());\n\n    }\n}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "outputs": {
                "description": "A collection of values returned by getSshKeys.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "keys": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/danubedata:index/getSshKeysKey:getSshKeysKey"
                        },
                        "description": "List of SSH keys. Each key contains:\n"
                    }
                },
                "type": "object",
                "required": [
                    "keys",
                    "id"
                ]
            }
        },
        "danubedata:index/getStorageAccessKeys:getStorageAccessKeys": {
            "description": "## # danubedata.getStorageAccessKeys\n\nLists all S3 storage access keys in your account.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as danubedata from \"@pulumi/danubedata\";\n\nconst all = danubedata.getStorageAccessKeys({});\nexport const keyCount = all.then(all =\u003e all.keys).length;\nexport const activeKeys = all.then(all =\u003e .filter(k =\u003e k.status == \"active\").map(k =\u003e (k.name)));\n```\n```python\nimport pulumi\nimport pulumi_danubedata as danubedata\n\nall = danubedata.get_storage_access_keys()\npulumi.export(\"keyCount\", len(all.keys))\npulumi.export(\"activeKeys\", [k.name for k in all.keys if k.status == \"active\"])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing DanubeData = Pulumi.DanubeData;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var all = DanubeData.GetStorageAccessKeys.Invoke();\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"keyCount\"] = all.Apply(getStorageAccessKeysResult =\u003e getStorageAccessKeysResult.Keys).Length,\n        [\"activeKeys\"] = .Where(k =\u003e k.Status == \"active\").Select(k =\u003e \n        {\n            return k.Name;\n        }).ToList(),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/AdrianSilaghi/pulumi-danubedata/sdk/go/danubedata\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tall, err := danubedata.GetStorageAccessKeys(ctx, map[string]interface{}{}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"keyCount\", pulumi.Int(len(all.Keys)))\n\t\tctx.Export(\"activeKeys\", pulumi.StringArray(\"TODO: For expression\"))\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.danubedata.DanubedataFunctions;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var all = DanubedataFunctions.getStorageAccessKeys();\n\n        ctx.export(\"keyCount\", all.applyValue(getStorageAccessKeysResult -\u003e getStorageAccessKeysResult.keys()).length());\n        ctx.export(\"activeKeys\", \"TODO: ForExpression\");\n    }\n}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Find Key by Name\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as danubedata from \"@pulumi/danubedata\";\n\nconst all = danubedata.getStorageAccessKeys({});\nconst appKey = all.then(all =\u003e .filter(k =\u003e k.name == \"app-access-key\").map(k =\u003e (k))[0]);\nexport const appAccessKeyId = appKey.accessKeyId;\n```\n```python\nimport pulumi\nimport pulumi_danubedata as danubedata\n\nall = danubedata.get_storage_access_keys()\napp_key = [k for k in all.keys if k.name == \"app-access-key\"][0]\npulumi.export(\"appAccessKeyId\", app_key.access_key_id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing DanubeData = Pulumi.DanubeData;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var all = DanubeData.GetStorageAccessKeys.Invoke();\n\n    var appKey = .Where(k =\u003e k.Name == \"app-access-key\").Select(k =\u003e \n    {\n        return k;\n    }).ToList()[0];\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"appAccessKeyId\"] = appKey.AccessKeyId,\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/AdrianSilaghi/pulumi-danubedata/sdk/go/danubedata\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tall, err := danubedata.GetStorageAccessKeys(ctx, map[string]interface{}{}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tappKey := \"TODO: For expression\"[0]\n\t\tctx.Export(\"appAccessKeyId\", appKey.AccessKeyId)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.danubedata.DanubedataFunctions;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var all = DanubedataFunctions.getStorageAccessKeys();\n\n        final var appKey = \"TODO: ForExpression\"[0];\n\n        ctx.export(\"appAccessKeyId\", appKey.accessKeyId());\n    }\n}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Filter Active Keys\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as danubedata from \"@pulumi/danubedata\";\n\nconst all = danubedata.getStorageAccessKeys({});\nconst activeKeys = all.then(all =\u003e .filter(k =\u003e k.status == \"active\" \u0026\u0026 !k.isExpired).map(k =\u003e (k)));\nconst expiredKeys = all.then(all =\u003e .filter(k =\u003e k.isExpired).map(k =\u003e (k)));\nexport const activeCount = activeKeys.length;\nexport const expiredCount = expiredKeys.apply(expiredKeys =\u003e expiredKeys.length);\n```\n```python\nimport pulumi\nimport pulumi_danubedata as danubedata\n\nall = danubedata.get_storage_access_keys()\nactive_keys = [k for k in all.keys if k.status == \"active\" and not k.is_expired]\nexpired_keys = [k for k in all.keys if k.is_expired]\npulumi.export(\"activeCount\", len(active_keys))\npulumi.export(\"expiredCount\", len(expired_keys))\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing DanubeData = Pulumi.DanubeData;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var all = DanubeData.GetStorageAccessKeys.Invoke();\n\n    var activeKeys = .Where(k =\u003e k.Status == \"active\" \u0026\u0026 !k.IsExpired).Select(k =\u003e \n    {\n        return k;\n    }).ToList();\n\n    var expiredKeys = ;\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"activeCount\"] = activeKeys.Length,\n        [\"expiredCount\"] = expiredKeys.Apply(expiredKeys =\u003e expiredKeys.Length),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/AdrianSilaghi/pulumi-danubedata/sdk/go/danubedata\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tall, err := danubedata.GetStorageAccessKeys(ctx, map[string]interface{}{}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tactiveKeys := \"TODO: For expression\"\n\t\texpiredKeys := \"TODO: For expression\"\n\t\tctx.Export(\"activeCount\", pulumi.Int(len(activeKeys)))\n\t\tctx.Export(\"expiredCount\", pulumi.Int(len(expiredKeys)))\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.danubedata.DanubedataFunctions;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var all = DanubedataFunctions.getStorageAccessKeys();\n\n        final var activeKeys = \"TODO: ForExpression\";\n\n        final var expiredKeys = \"TODO: ForExpression\";\n\n        ctx.export(\"activeCount\", activeKeys.length());\n        ctx.export(\"expiredCount\", expiredKeys.length());\n    }\n}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Notes\n\n- The `secret_access_key` is not included in this data source for security reasons.\n- Secret access keys are only available during creation.\n- To get a new secret key, create a new access key resource.\n",
            "outputs": {
                "description": "A collection of values returned by getStorageAccessKeys.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "keys": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/danubedata:index/getStorageAccessKeysKey:getStorageAccessKeysKey"
                        },
                        "description": "List of storage access keys. Each key contains:\n"
                    }
                },
                "type": "object",
                "required": [
                    "keys",
                    "id"
                ]
            }
        },
        "danubedata:index/getStorageBuckets:getStorageBuckets": {
            "description": "## # danubedata.getStorageBuckets\n\nLists all S3-compatible storage buckets in your account.\n\n### Find Bucket by Name\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as danubedata from \"@pulumi/danubedata\";\n\nconst all = danubedata.getStorageBuckets({});\nconst assetsBucket = all.then(all =\u003e .filter(b =\u003e b.name == \"assets\").map(b =\u003e (b))[0]);\nexport const assetsEndpoint = assetsBucket.endpointUrl;\nexport const assetsBucketName = assetsBucket.minioBucketName;\n```\n```python\nimport pulumi\nimport pulumi_danubedata as danubedata\n\nall = danubedata.get_storage_buckets()\nassets_bucket = [b for b in all.buckets if b.name == \"assets\"][0]\npulumi.export(\"assetsEndpoint\", assets_bucket.endpoint_url)\npulumi.export(\"assetsBucketName\", assets_bucket.minio_bucket_name)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing DanubeData = Pulumi.DanubeData;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var all = DanubeData.GetStorageBuckets.Invoke();\n\n    var assetsBucket = .Where(b =\u003e b.Name == \"assets\").Select(b =\u003e \n    {\n        return b;\n    }).ToList()[0];\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"assetsEndpoint\"] = assetsBucket.EndpointUrl,\n        [\"assetsBucketName\"] = assetsBucket.MinioBucketName,\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/AdrianSilaghi/pulumi-danubedata/sdk/go/danubedata\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tall, err := danubedata.GetStorageBuckets(ctx, map[string]interface{}{}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tassetsBucket := \"TODO: For expression\"[0]\n\t\tctx.Export(\"assetsEndpoint\", assetsBucket.EndpointUrl)\n\t\tctx.Export(\"assetsBucketName\", assetsBucket.MinioBucketName)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.danubedata.DanubedataFunctions;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var all = DanubedataFunctions.getStorageBuckets();\n\n        final var assetsBucket = \"TODO: ForExpression\"[0];\n\n        ctx.export(\"assetsEndpoint\", assetsBucket.endpointUrl());\n        ctx.export(\"assetsBucketName\", assetsBucket.minioBucketName());\n    }\n}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Filter Public Buckets\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as danubedata from \"@pulumi/danubedata\";\n\nconst all = danubedata.getStorageBuckets({});\nconst publicBuckets = all.then(all =\u003e .filter(b =\u003e b.publicAccess).map(b =\u003e (b)));\nexport const publicBucketUrls = publicBuckets.apply(publicBuckets =\u003e publicBuckets.map(b =\u003e (b.publicUrl)));\n```\n```python\nimport pulumi\nimport pulumi_danubedata as danubedata\n\nall = danubedata.get_storage_buckets()\npublic_buckets = [b for b in all.buckets if b.public_access]\npulumi.export(\"publicBucketUrls\", [b.public_url for b in public_buckets])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing DanubeData = Pulumi.DanubeData;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var all = DanubeData.GetStorageBuckets.Invoke();\n\n    var publicBuckets = ;\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"publicBucketUrls\"] = publicBuckets.Apply(publicBuckets =\u003e publicBuckets.Select(b =\u003e \n        {\n            return b.PublicUrl;\n        }).ToList()),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/AdrianSilaghi/pulumi-danubedata/sdk/go/danubedata\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tall, err := danubedata.GetStorageBuckets(ctx, map[string]interface{}{}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tpublicBuckets := \"TODO: For expression\"\n\t\tctx.Export(\"publicBucketUrls\", pulumi.StringArray(\"TODO: For expression\"))\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.danubedata.DanubedataFunctions;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var all = DanubedataFunctions.getStorageBuckets();\n\n        final var publicBuckets = \"TODO: ForExpression\";\n\n        ctx.export(\"publicBucketUrls\", \"TODO: ForExpression\");\n    }\n}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "outputs": {
                "description": "A collection of values returned by getStorageBuckets.\n",
                "properties": {
                    "buckets": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/danubedata:index/getStorageBucketsBucket:getStorageBucketsBucket"
                        },
                        "description": "List of storage buckets. Each bucket contains:\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    }
                },
                "type": "object",
                "required": [
                    "buckets",
                    "id"
                ]
            }
        },
        "danubedata:index/getVpsImages:getVpsImages": {
            "description": "## # danubedata.getVpsImages\n\nLists available VPS operating system images.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as danubedata from \"@pulumi/danubedata\";\n\nconst all = danubedata.getVpsImages({});\nexport const availableImages = all.then(all =\u003e .map(img =\u003e (img.image)));\n```\n```python\nimport pulumi\nimport pulumi_danubedata as danubedata\n\nall = danubedata.get_vps_images()\npulumi.export(\"availableImages\", [img.image for img in all.images])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing DanubeData = Pulumi.DanubeData;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var all = DanubeData.GetVpsImages.Invoke();\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"availableImages\"] = .Select(img =\u003e \n        {\n            return img.Image;\n        }).ToList(),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/AdrianSilaghi/pulumi-danubedata/sdk/go/danubedata\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tall, err := danubedata.GetVpsImages(ctx, map[string]interface{}{}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"availableImages\", pulumi.StringArray(\"TODO: For expression\"))\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.danubedata.DanubedataFunctions;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var all = DanubedataFunctions.getVpsImages();\n\n        ctx.export(\"availableImages\", \"TODO: ForExpression\");\n    }\n}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Filter Ubuntu Images\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as danubedata from \"@pulumi/danubedata\";\n\nconst all = danubedata.getVpsImages({});\nconst myUbuntuImages = all.then(all =\u003e .filter(img =\u003e img.distro == \"ubuntu\").map(img =\u003e (img)));\nexport const ubuntuImages = myUbuntuImages.map(img =\u003e (img.image));\n```\n```python\nimport pulumi\nimport pulumi_danubedata as danubedata\n\nall = danubedata.get_vps_images()\nmy_ubuntu_images = [img for img in all.images if img.distro == \"ubuntu\"]\npulumi.export(\"ubuntuImages\", [img.image for img in my_ubuntu_images])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing DanubeData = Pulumi.DanubeData;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var all = DanubeData.GetVpsImages.Invoke();\n\n    var myUbuntuImages = .Where(img =\u003e img.Distro == \"ubuntu\").Select(img =\u003e \n    {\n        return img;\n    }).ToList();\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"ubuntuImages\"] = myUbuntuImages,\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/AdrianSilaghi/pulumi-danubedata/sdk/go/danubedata\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tall, err := danubedata.GetVpsImages(ctx, map[string]interface{}{}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tmyUbuntuImages := \"TODO: For expression\"\n\t\tctx.Export(\"ubuntuImages\", pulumi.StringArray(\"TODO: For expression\"))\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.danubedata.DanubedataFunctions;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var all = DanubedataFunctions.getVpsImages();\n\n        final var myUbuntuImages = \"TODO: ForExpression\";\n\n        ctx.export(\"ubuntuImages\", \"TODO: ForExpression\");\n    }\n}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n",
            "outputs": {
                "description": "A collection of values returned by getVpsImages.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "images": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/danubedata:index/getVpsImagesImage:getVpsImagesImage"
                        },
                        "description": "List of available images. Each image contains:\n"
                    }
                },
                "type": "object",
                "required": [
                    "images",
                    "id"
                ]
            }
        },
        "danubedata:index/getVpsSnapshots:getVpsSnapshots": {
            "description": "## # danubedata.getVpsSnapshots\n\nLists all VPS snapshots in your account.\n\n### Find Snapshot by Name\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as danubedata from \"@pulumi/danubedata\";\n\nconst all = danubedata.getVpsSnapshots({});\nconst preUpgrade = all.then(all =\u003e .filter(s =\u003e s.name == \"pre-upgrade-backup\").map(s =\u003e (s))[0]);\nexport const preUpgradeSnapshotId = preUpgrade.id;\n```\n```python\nimport pulumi\nimport pulumi_danubedata as danubedata\n\nall = danubedata.get_vps_snapshots()\npre_upgrade = [s for s in all.snapshots if s.name == \"pre-upgrade-backup\"][0]\npulumi.export(\"preUpgradeSnapshotId\", pre_upgrade.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing DanubeData = Pulumi.DanubeData;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var all = DanubeData.GetVpsSnapshots.Invoke();\n\n    var preUpgrade = .Where(s =\u003e s.Name == \"pre-upgrade-backup\").Select(s =\u003e \n    {\n        return s;\n    }).ToList()[0];\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"preUpgradeSnapshotId\"] = preUpgrade.Id,\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/AdrianSilaghi/pulumi-danubedata/sdk/go/danubedata\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tall, err := danubedata.GetVpsSnapshots(ctx, map[string]interface{}{}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tpreUpgrade := \"TODO: For expression\"[0]\n\t\tctx.Export(\"preUpgradeSnapshotId\", preUpgrade.Id)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.danubedata.DanubedataFunctions;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var all = DanubedataFunctions.getVpsSnapshots();\n\n        final var preUpgrade = \"TODO: ForExpression\"[0];\n\n        ctx.export(\"preUpgradeSnapshotId\", preUpgrade.id());\n    }\n}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Filter Snapshots by VPS Instance\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as danubedata from \"@pulumi/danubedata\";\n\nconst all = danubedata.getVpsSnapshots({});\nconst config = new pulumi.Config();\nconst vpsId = config.get(\"vpsId\") || \"vps-abc123\";\nconst vpsSnapshots = all.then(all =\u003e .filter(s =\u003e s.vpsInstanceId == vpsId).map(s =\u003e (s)));\nexport const vpsSnapshotCount = vpsSnapshots.length;\n```\n```python\nimport pulumi\nimport pulumi_danubedata as danubedata\n\nall = danubedata.get_vps_snapshots()\nconfig = pulumi.Config()\nvps_id = config.get(\"vpsId\")\nif vps_id is None:\n    vps_id = \"vps-abc123\"\nvps_snapshots = [s for s in all.snapshots if s.vps_instance_id == vps_id]\npulumi.export(\"vpsSnapshotCount\", len(vps_snapshots))\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing DanubeData = Pulumi.DanubeData;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var all = DanubeData.GetVpsSnapshots.Invoke();\n\n    var config = new Config();\n    var vpsId = config.Get(\"vpsId\") ?? \"vps-abc123\";\n    var vpsSnapshots = .Where(s =\u003e s.VpsInstanceId == vpsId).Select(s =\u003e \n    {\n        return s;\n    }).ToList();\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"vpsSnapshotCount\"] = vpsSnapshots.Length,\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/AdrianSilaghi/pulumi-danubedata/sdk/go/danubedata\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi/config\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tall, err := danubedata.GetVpsSnapshots(ctx, map[string]interface{}{}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tcfg := config.New(ctx, \"\")\n\t\tvpsId := \"vps-abc123\"\n\t\tif param := cfg.Get(\"vpsId\"); param != \"\" {\n\t\t\tvpsId = param\n\t\t}\n\t\tvpsSnapshots := \"TODO: For expression\"\n\t\tctx.Export(\"vpsSnapshotCount\", pulumi.Int(len(vpsSnapshots)))\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.danubedata.DanubedataFunctions;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var config = ctx.config();\n        final var all = DanubedataFunctions.getVpsSnapshots();\n\n        final var vpsId = config.get(\"vpsId\").orElse(\"vps-abc123\");\n        final var vpsSnapshots = \"TODO: ForExpression\";\n\n        ctx.export(\"vpsSnapshotCount\", vpsSnapshots.length());\n    }\n}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Filter Ready Snapshots\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as danubedata from \"@pulumi/danubedata\";\n\nconst all = danubedata.getVpsSnapshots({});\nconst readySnapshots = all.then(all =\u003e .filter(s =\u003e s.status == \"ready\").map(s =\u003e (s)));\nexport const readyCount = readySnapshots.length;\n```\n```python\nimport pulumi\nimport pulumi_danubedata as danubedata\n\nall = danubedata.get_vps_snapshots()\nready_snapshots = [s for s in all.snapshots if s.status == \"ready\"]\npulumi.export(\"readyCount\", len(ready_snapshots))\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing DanubeData = Pulumi.DanubeData;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var all = DanubeData.GetVpsSnapshots.Invoke();\n\n    var readySnapshots = .Where(s =\u003e s.Status == \"ready\").Select(s =\u003e \n    {\n        return s;\n    }).ToList();\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"readyCount\"] = readySnapshots.Length,\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/AdrianSilaghi/pulumi-danubedata/sdk/go/danubedata\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tall, err := danubedata.GetVpsSnapshots(ctx, map[string]interface{}{}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treadySnapshots := \"TODO: For expression\"\n\t\tctx.Export(\"readyCount\", pulumi.Int(len(readySnapshots)))\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.danubedata.DanubedataFunctions;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var all = DanubedataFunctions.getVpsSnapshots();\n\n        final var readySnapshots = \"TODO: ForExpression\";\n\n        ctx.export(\"readyCount\", readySnapshots.length());\n    }\n}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "outputs": {
                "description": "A collection of values returned by getVpsSnapshots.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "snapshots": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/danubedata:index/getVpsSnapshotsSnapshot:getVpsSnapshotsSnapshot"
                        },
                        "description": "List of VPS snapshots. Each snapshot contains:\n"
                    }
                },
                "type": "object",
                "required": [
                    "snapshots",
                    "id"
                ]
            }
        },
        "danubedata:index/getVpss:getVpss": {
            "description": "## # danubedata.getVpss\n\nLists all VPS instances in your account.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as danubedata from \"@pulumi/danubedata\";\n\nconst all = danubedata.getVpss({});\nexport const vpsCount = all.then(all =\u003e all.instances).length;\nexport const vpsNames = all.then(all =\u003e .map(vps =\u003e (vps.name)));\n```\n```python\nimport pulumi\nimport pulumi_danubedata as danubedata\n\nall = danubedata.get_vpss()\npulumi.export(\"vpsCount\", len(all.instances))\npulumi.export(\"vpsNames\", [vps.name for vps in all.instances])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing DanubeData = Pulumi.DanubeData;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var all = DanubeData.GetVpss.Invoke();\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"vpsCount\"] = all.Apply(getVpssResult =\u003e getVpssResult.Instances).Length,\n        [\"vpsNames\"] = .Select(vps =\u003e \n        {\n            return vps.Name;\n        }).ToList(),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/AdrianSilaghi/pulumi-danubedata/sdk/go/danubedata\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tall, err := danubedata.GetVpss(ctx, map[string]interface{}{}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"vpsCount\", pulumi.Int(len(all.Instances)))\n\t\tctx.Export(\"vpsNames\", pulumi.StringArray(\"TODO: For expression\"))\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.danubedata.DanubedataFunctions;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var all = DanubedataFunctions.getVpss();\n\n        ctx.export(\"vpsCount\", all.applyValue(getVpssResult -\u003e getVpssResult.instances()).length());\n        ctx.export(\"vpsNames\", \"TODO: ForExpression\");\n    }\n}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Find VPS by Name\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as danubedata from \"@pulumi/danubedata\";\n\nconst all = danubedata.getVpss({});\nconst webServer = all.then(all =\u003e .filter(vps =\u003e vps.name == \"web-server\").map(vps =\u003e (vps))[0]);\nexport const webServerIp = webServer.publicIp;\n```\n```python\nimport pulumi\nimport pulumi_danubedata as danubedata\n\nall = danubedata.get_vpss()\nweb_server = [vps for vps in all.instances if vps.name == \"web-server\"][0]\npulumi.export(\"webServerIp\", web_server.public_ip)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing DanubeData = Pulumi.DanubeData;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var all = DanubeData.GetVpss.Invoke();\n\n    var webServer = .Where(vps =\u003e vps.Name == \"web-server\").Select(vps =\u003e \n    {\n        return vps;\n    }).ToList()[0];\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"webServerIp\"] = webServer.PublicIp,\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/AdrianSilaghi/pulumi-danubedata/sdk/go/danubedata\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tall, err := danubedata.GetVpss(ctx, map[string]interface{}{}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\twebServer := \"TODO: For expression\"[0]\n\t\tctx.Export(\"webServerIp\", webServer.PublicIp)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.danubedata.DanubedataFunctions;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var all = DanubedataFunctions.getVpss();\n\n        final var webServer = \"TODO: ForExpression\"[0];\n\n        ctx.export(\"webServerIp\", webServer.publicIp());\n    }\n}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Filter Running Instances\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as danubedata from \"@pulumi/danubedata\";\n\nconst all = danubedata.getVpss({});\nconst runningInstances = all.then(all =\u003e .filter(vps =\u003e vps.status == \"running\").map(vps =\u003e (vps)));\nexport const runningCount = runningInstances.length;\n```\n```python\nimport pulumi\nimport pulumi_danubedata as danubedata\n\nall = danubedata.get_vpss()\nrunning_instances = [vps for vps in all.instances if vps.status == \"running\"]\npulumi.export(\"runningCount\", len(running_instances))\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing DanubeData = Pulumi.DanubeData;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var all = DanubeData.GetVpss.Invoke();\n\n    var runningInstances = .Where(vps =\u003e vps.Status == \"running\").Select(vps =\u003e \n    {\n        return vps;\n    }).ToList();\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"runningCount\"] = runningInstances.Length,\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/AdrianSilaghi/pulumi-danubedata/sdk/go/danubedata\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tall, err := danubedata.GetVpss(ctx, map[string]interface{}{}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\trunningInstances := \"TODO: For expression\"\n\t\tctx.Export(\"runningCount\", pulumi.Int(len(runningInstances)))\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.danubedata.DanubedataFunctions;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var all = DanubedataFunctions.getVpss();\n\n        final var runningInstances = \"TODO: ForExpression\";\n\n        ctx.export(\"runningCount\", runningInstances.length());\n    }\n}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "outputs": {
                "description": "A collection of values returned by getVpss.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "instances": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/danubedata:index/getVpssInstance:getVpssInstance"
                        },
                        "description": "List of VPS instances. Each instance contains:\n"
                    }
                },
                "type": "object",
                "required": [
                    "instances",
                    "id"
                ]
            }
        }
    }
}