// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package danubedata

import (
	"context"
	"reflect"

	"errors"
	"github.com/AdrianSilaghi/pulumi-danubedata/sdk/go/danubedata/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// ## # Serverless
//
// Manages a serverless container with automatic scaling and scale-to-zero support.
//
// ## Example Usage
//
// ### Docker Image Deployment
//
// ```go
// package main
//
// import (
//
//	"github.com/AdrianSilaghi/pulumi-danubedata/sdk/go/danubedata"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			nginx, err := danubedata.NewServerless(ctx, "nginx", &danubedata.ServerlessArgs{
//				DeploymentType: pulumi.String("docker"),
//				ImageUrl:       pulumi.String("nginx:latest"),
//				Port:           pulumi.Int(80),
//				MinInstances:   pulumi.Int(0),
//				MaxInstances:   pulumi.Int(10),
//			})
//			if err != nil {
//				return err
//			}
//			ctx.Export("appUrl", nginx.Url)
//			return nil
//		})
//	}
//
// ```
//
// ### Git Repository Deployment
//
// ```go
// package main
//
// import (
//
//	"github.com/AdrianSilaghi/pulumi-danubedata/sdk/go/danubedata"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := danubedata.NewServerless(ctx, "app", &danubedata.ServerlessArgs{
//				DeploymentType: pulumi.String("git"),
//				EnvironmentVariables: pulumi.StringMap{
//					"LOG_LEVEL": pulumi.String("info"),
//					"NODE_ENV":  pulumi.String("production"),
//				},
//				GitBranch:     pulumi.String("main"),
//				GitRepository: pulumi.String("https://github.com/user/my-app"),
//				MaxInstances:  pulumi.Int(5),
//				MinInstances:  pulumi.Int(1),
//				Port:          pulumi.Int(8080),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ### With Resource Profile
//
// ```go
// package main
//
// import (
//
//	"github.com/AdrianSilaghi/pulumi-danubedata/sdk/go/danubedata"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := danubedata.NewServerless(ctx, "api", &danubedata.ServerlessArgs{
//				DeploymentType: pulumi.String("docker"),
//				EnvironmentVariables: pulumi.StringMap{
//					"DATABASE_URL": pulumi.String("postgres://..."),
//					"REDIS_URL":    pulumi.String("redis://..."),
//				},
//				ImageUrl:        pulumi.String("myregistry/api:v1.0"),
//				MaxInstances:    pulumi.Int(20),
//				MinInstances:    pulumi.Int(2),
//				Port:            pulumi.Int(3000),
//				ResourceProfile: pulumi.String("medium"),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ### Scale to Zero Configuration
//
// ```go
// package main
//
// import (
//
//	"github.com/AdrianSilaghi/pulumi-danubedata/sdk/go/danubedata"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := danubedata.NewServerless(ctx, "webhook", &danubedata.ServerlessArgs{
//				DeploymentType: pulumi.String("docker"),
//				ImageUrl:       pulumi.String("myregistry/webhook:latest"),
//				MaxInstances:   pulumi.Int(100),
//				MinInstances:   pulumi.Int(0),
//				Port:           pulumi.Int(8080),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Scaling Behavior
//
// - **min_instances = 0**: Container scales to zero after idle period (cost-effective)
// - **min_instances >= 1**: Always keeps instances running (no cold starts)
// - Scales up automatically based on traffic
// - Scales down when traffic decreases
//
// ## Build Process (Git Deployment)
//
// When using `git` deployment type:
// 1. Repository is cloned
// 2. Buildpack detection or Dockerfile is used
// 3. Container image is built
// 4. Image is deployed to serverless platform
// 5. Automatic rebuilds on git push (via webhook)
//
// ## Import
//
// Serverless containers can be imported using their ID:
//
// bash
//
// ```sh
// $ pulumi import danubedata:index/serverless:Serverless example srv-abc123
// ```
type Serverless struct {
	pulumi.CustomResourceState

	// Creation timestamp.
	CreatedAt pulumi.StringOutput `pulumi:"createdAt"`
	// Current month's cost in cents.
	CurrentMonthCostCents pulumi.IntOutput `pulumi:"currentMonthCostCents"`
	// Deployment type: 'image' for Docker image, 'git' for Git repository.
	DeploymentType pulumi.StringOutput `pulumi:"deploymentType"`
	// Environment variables for the container.
	EnvironmentVariables pulumi.StringMapOutput `pulumi:"environmentVariables"`
	// Git branch to deploy.
	GitBranch pulumi.StringOutput `pulumi:"gitBranch"`
	// Git repository URL (required if deploymentType is 'git').
	GitRepository pulumi.StringPtrOutput `pulumi:"gitRepository"`
	// Docker image URL (required if deploymentType is 'image').
	ImageUrl pulumi.StringPtrOutput `pulumi:"imageUrl"`
	// Maximum number of instances.
	MaxInstances pulumi.IntOutput `pulumi:"maxInstances"`
	// Minimum number of instances (0 for scale-to-zero).
	MinInstances pulumi.IntOutput `pulumi:"minInstances"`
	// Name of the serverless container.
	Name pulumi.StringOutput `pulumi:"name"`
	// Port the container listens on.
	Port pulumi.IntOutput `pulumi:"port"`
	// Resource profile for the container (small, medium, large).
	ResourceProfile pulumi.StringOutput `pulumi:"resourceProfile"`
	// Current status.
	Status   pulumi.StringOutput         `pulumi:"status"`
	Timeouts ServerlessTimeoutsPtrOutput `pulumi:"timeouts"`
	// Timestamp when the container was last updated.
	UpdatedAt pulumi.StringOutput `pulumi:"updatedAt"`
	// Public HTTPS URL for the container.
	Url pulumi.StringOutput `pulumi:"url"`
}

// NewServerless registers a new resource with the given unique name, arguments, and options.
func NewServerless(ctx *pulumi.Context,
	name string, args *ServerlessArgs, opts ...pulumi.ResourceOption) (*Serverless, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.DeploymentType == nil {
		return nil, errors.New("invalid value for required argument 'DeploymentType'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Serverless
	err := ctx.RegisterResource("danubedata:index/serverless:Serverless", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetServerless gets an existing Serverless resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetServerless(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *ServerlessState, opts ...pulumi.ResourceOption) (*Serverless, error) {
	var resource Serverless
	err := ctx.ReadResource("danubedata:index/serverless:Serverless", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Serverless resources.
type serverlessState struct {
	// Creation timestamp.
	CreatedAt *string `pulumi:"createdAt"`
	// Current month's cost in cents.
	CurrentMonthCostCents *int `pulumi:"currentMonthCostCents"`
	// Deployment type: 'image' for Docker image, 'git' for Git repository.
	DeploymentType *string `pulumi:"deploymentType"`
	// Environment variables for the container.
	EnvironmentVariables map[string]string `pulumi:"environmentVariables"`
	// Git branch to deploy.
	GitBranch *string `pulumi:"gitBranch"`
	// Git repository URL (required if deploymentType is 'git').
	GitRepository *string `pulumi:"gitRepository"`
	// Docker image URL (required if deploymentType is 'image').
	ImageUrl *string `pulumi:"imageUrl"`
	// Maximum number of instances.
	MaxInstances *int `pulumi:"maxInstances"`
	// Minimum number of instances (0 for scale-to-zero).
	MinInstances *int `pulumi:"minInstances"`
	// Name of the serverless container.
	Name *string `pulumi:"name"`
	// Port the container listens on.
	Port *int `pulumi:"port"`
	// Resource profile for the container (small, medium, large).
	ResourceProfile *string `pulumi:"resourceProfile"`
	// Current status.
	Status   *string             `pulumi:"status"`
	Timeouts *ServerlessTimeouts `pulumi:"timeouts"`
	// Timestamp when the container was last updated.
	UpdatedAt *string `pulumi:"updatedAt"`
	// Public HTTPS URL for the container.
	Url *string `pulumi:"url"`
}

type ServerlessState struct {
	// Creation timestamp.
	CreatedAt pulumi.StringPtrInput
	// Current month's cost in cents.
	CurrentMonthCostCents pulumi.IntPtrInput
	// Deployment type: 'image' for Docker image, 'git' for Git repository.
	DeploymentType pulumi.StringPtrInput
	// Environment variables for the container.
	EnvironmentVariables pulumi.StringMapInput
	// Git branch to deploy.
	GitBranch pulumi.StringPtrInput
	// Git repository URL (required if deploymentType is 'git').
	GitRepository pulumi.StringPtrInput
	// Docker image URL (required if deploymentType is 'image').
	ImageUrl pulumi.StringPtrInput
	// Maximum number of instances.
	MaxInstances pulumi.IntPtrInput
	// Minimum number of instances (0 for scale-to-zero).
	MinInstances pulumi.IntPtrInput
	// Name of the serverless container.
	Name pulumi.StringPtrInput
	// Port the container listens on.
	Port pulumi.IntPtrInput
	// Resource profile for the container (small, medium, large).
	ResourceProfile pulumi.StringPtrInput
	// Current status.
	Status   pulumi.StringPtrInput
	Timeouts ServerlessTimeoutsPtrInput
	// Timestamp when the container was last updated.
	UpdatedAt pulumi.StringPtrInput
	// Public HTTPS URL for the container.
	Url pulumi.StringPtrInput
}

func (ServerlessState) ElementType() reflect.Type {
	return reflect.TypeOf((*serverlessState)(nil)).Elem()
}

type serverlessArgs struct {
	// Deployment type: 'image' for Docker image, 'git' for Git repository.
	DeploymentType string `pulumi:"deploymentType"`
	// Environment variables for the container.
	EnvironmentVariables map[string]string `pulumi:"environmentVariables"`
	// Git branch to deploy.
	GitBranch *string `pulumi:"gitBranch"`
	// Git repository URL (required if deploymentType is 'git').
	GitRepository *string `pulumi:"gitRepository"`
	// Docker image URL (required if deploymentType is 'image').
	ImageUrl *string `pulumi:"imageUrl"`
	// Maximum number of instances.
	MaxInstances *int `pulumi:"maxInstances"`
	// Minimum number of instances (0 for scale-to-zero).
	MinInstances *int `pulumi:"minInstances"`
	// Name of the serverless container.
	Name *string `pulumi:"name"`
	// Port the container listens on.
	Port *int `pulumi:"port"`
	// Resource profile for the container (small, medium, large).
	ResourceProfile *string             `pulumi:"resourceProfile"`
	Timeouts        *ServerlessTimeouts `pulumi:"timeouts"`
}

// The set of arguments for constructing a Serverless resource.
type ServerlessArgs struct {
	// Deployment type: 'image' for Docker image, 'git' for Git repository.
	DeploymentType pulumi.StringInput
	// Environment variables for the container.
	EnvironmentVariables pulumi.StringMapInput
	// Git branch to deploy.
	GitBranch pulumi.StringPtrInput
	// Git repository URL (required if deploymentType is 'git').
	GitRepository pulumi.StringPtrInput
	// Docker image URL (required if deploymentType is 'image').
	ImageUrl pulumi.StringPtrInput
	// Maximum number of instances.
	MaxInstances pulumi.IntPtrInput
	// Minimum number of instances (0 for scale-to-zero).
	MinInstances pulumi.IntPtrInput
	// Name of the serverless container.
	Name pulumi.StringPtrInput
	// Port the container listens on.
	Port pulumi.IntPtrInput
	// Resource profile for the container (small, medium, large).
	ResourceProfile pulumi.StringPtrInput
	Timeouts        ServerlessTimeoutsPtrInput
}

func (ServerlessArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*serverlessArgs)(nil)).Elem()
}

type ServerlessInput interface {
	pulumi.Input

	ToServerlessOutput() ServerlessOutput
	ToServerlessOutputWithContext(ctx context.Context) ServerlessOutput
}

func (*Serverless) ElementType() reflect.Type {
	return reflect.TypeOf((**Serverless)(nil)).Elem()
}

func (i *Serverless) ToServerlessOutput() ServerlessOutput {
	return i.ToServerlessOutputWithContext(context.Background())
}

func (i *Serverless) ToServerlessOutputWithContext(ctx context.Context) ServerlessOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServerlessOutput)
}

// ServerlessArrayInput is an input type that accepts ServerlessArray and ServerlessArrayOutput values.
// You can construct a concrete instance of `ServerlessArrayInput` via:
//
//	ServerlessArray{ ServerlessArgs{...} }
type ServerlessArrayInput interface {
	pulumi.Input

	ToServerlessArrayOutput() ServerlessArrayOutput
	ToServerlessArrayOutputWithContext(context.Context) ServerlessArrayOutput
}

type ServerlessArray []ServerlessInput

func (ServerlessArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Serverless)(nil)).Elem()
}

func (i ServerlessArray) ToServerlessArrayOutput() ServerlessArrayOutput {
	return i.ToServerlessArrayOutputWithContext(context.Background())
}

func (i ServerlessArray) ToServerlessArrayOutputWithContext(ctx context.Context) ServerlessArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServerlessArrayOutput)
}

// ServerlessMapInput is an input type that accepts ServerlessMap and ServerlessMapOutput values.
// You can construct a concrete instance of `ServerlessMapInput` via:
//
//	ServerlessMap{ "key": ServerlessArgs{...} }
type ServerlessMapInput interface {
	pulumi.Input

	ToServerlessMapOutput() ServerlessMapOutput
	ToServerlessMapOutputWithContext(context.Context) ServerlessMapOutput
}

type ServerlessMap map[string]ServerlessInput

func (ServerlessMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Serverless)(nil)).Elem()
}

func (i ServerlessMap) ToServerlessMapOutput() ServerlessMapOutput {
	return i.ToServerlessMapOutputWithContext(context.Background())
}

func (i ServerlessMap) ToServerlessMapOutputWithContext(ctx context.Context) ServerlessMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ServerlessMapOutput)
}

type ServerlessOutput struct{ *pulumi.OutputState }

func (ServerlessOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Serverless)(nil)).Elem()
}

func (o ServerlessOutput) ToServerlessOutput() ServerlessOutput {
	return o
}

func (o ServerlessOutput) ToServerlessOutputWithContext(ctx context.Context) ServerlessOutput {
	return o
}

// Creation timestamp.
func (o ServerlessOutput) CreatedAt() pulumi.StringOutput {
	return o.ApplyT(func(v *Serverless) pulumi.StringOutput { return v.CreatedAt }).(pulumi.StringOutput)
}

// Current month's cost in cents.
func (o ServerlessOutput) CurrentMonthCostCents() pulumi.IntOutput {
	return o.ApplyT(func(v *Serverless) pulumi.IntOutput { return v.CurrentMonthCostCents }).(pulumi.IntOutput)
}

// Deployment type: 'image' for Docker image, 'git' for Git repository.
func (o ServerlessOutput) DeploymentType() pulumi.StringOutput {
	return o.ApplyT(func(v *Serverless) pulumi.StringOutput { return v.DeploymentType }).(pulumi.StringOutput)
}

// Environment variables for the container.
func (o ServerlessOutput) EnvironmentVariables() pulumi.StringMapOutput {
	return o.ApplyT(func(v *Serverless) pulumi.StringMapOutput { return v.EnvironmentVariables }).(pulumi.StringMapOutput)
}

// Git branch to deploy.
func (o ServerlessOutput) GitBranch() pulumi.StringOutput {
	return o.ApplyT(func(v *Serverless) pulumi.StringOutput { return v.GitBranch }).(pulumi.StringOutput)
}

// Git repository URL (required if deploymentType is 'git').
func (o ServerlessOutput) GitRepository() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Serverless) pulumi.StringPtrOutput { return v.GitRepository }).(pulumi.StringPtrOutput)
}

// Docker image URL (required if deploymentType is 'image').
func (o ServerlessOutput) ImageUrl() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Serverless) pulumi.StringPtrOutput { return v.ImageUrl }).(pulumi.StringPtrOutput)
}

// Maximum number of instances.
func (o ServerlessOutput) MaxInstances() pulumi.IntOutput {
	return o.ApplyT(func(v *Serverless) pulumi.IntOutput { return v.MaxInstances }).(pulumi.IntOutput)
}

// Minimum number of instances (0 for scale-to-zero).
func (o ServerlessOutput) MinInstances() pulumi.IntOutput {
	return o.ApplyT(func(v *Serverless) pulumi.IntOutput { return v.MinInstances }).(pulumi.IntOutput)
}

// Name of the serverless container.
func (o ServerlessOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *Serverless) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// Port the container listens on.
func (o ServerlessOutput) Port() pulumi.IntOutput {
	return o.ApplyT(func(v *Serverless) pulumi.IntOutput { return v.Port }).(pulumi.IntOutput)
}

// Resource profile for the container (small, medium, large).
func (o ServerlessOutput) ResourceProfile() pulumi.StringOutput {
	return o.ApplyT(func(v *Serverless) pulumi.StringOutput { return v.ResourceProfile }).(pulumi.StringOutput)
}

// Current status.
func (o ServerlessOutput) Status() pulumi.StringOutput {
	return o.ApplyT(func(v *Serverless) pulumi.StringOutput { return v.Status }).(pulumi.StringOutput)
}

func (o ServerlessOutput) Timeouts() ServerlessTimeoutsPtrOutput {
	return o.ApplyT(func(v *Serverless) ServerlessTimeoutsPtrOutput { return v.Timeouts }).(ServerlessTimeoutsPtrOutput)
}

// Timestamp when the container was last updated.
func (o ServerlessOutput) UpdatedAt() pulumi.StringOutput {
	return o.ApplyT(func(v *Serverless) pulumi.StringOutput { return v.UpdatedAt }).(pulumi.StringOutput)
}

// Public HTTPS URL for the container.
func (o ServerlessOutput) Url() pulumi.StringOutput {
	return o.ApplyT(func(v *Serverless) pulumi.StringOutput { return v.Url }).(pulumi.StringOutput)
}

type ServerlessArrayOutput struct{ *pulumi.OutputState }

func (ServerlessArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Serverless)(nil)).Elem()
}

func (o ServerlessArrayOutput) ToServerlessArrayOutput() ServerlessArrayOutput {
	return o
}

func (o ServerlessArrayOutput) ToServerlessArrayOutputWithContext(ctx context.Context) ServerlessArrayOutput {
	return o
}

func (o ServerlessArrayOutput) Index(i pulumi.IntInput) ServerlessOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Serverless {
		return vs[0].([]*Serverless)[vs[1].(int)]
	}).(ServerlessOutput)
}

type ServerlessMapOutput struct{ *pulumi.OutputState }

func (ServerlessMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Serverless)(nil)).Elem()
}

func (o ServerlessMapOutput) ToServerlessMapOutput() ServerlessMapOutput {
	return o
}

func (o ServerlessMapOutput) ToServerlessMapOutputWithContext(ctx context.Context) ServerlessMapOutput {
	return o
}

func (o ServerlessMapOutput) MapIndex(k pulumi.StringInput) ServerlessOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Serverless {
		return vs[0].(map[string]*Serverless)[vs[1].(string)]
	}).(ServerlessOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ServerlessInput)(nil)).Elem(), &Serverless{})
	pulumi.RegisterInputType(reflect.TypeOf((*ServerlessArrayInput)(nil)).Elem(), ServerlessArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ServerlessMapInput)(nil)).Elem(), ServerlessMap{})
	pulumi.RegisterOutputType(ServerlessOutput{})
	pulumi.RegisterOutputType(ServerlessArrayOutput{})
	pulumi.RegisterOutputType(ServerlessMapOutput{})
}
