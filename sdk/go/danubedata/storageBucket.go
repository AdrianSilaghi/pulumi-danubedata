// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package danubedata

import (
	"context"
	"reflect"

	"errors"
	"github.com/AdrianSilaghi/pulumi-danubedata/sdk/go/danubedata/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// ## # StorageBucket
//
// Manages an S3-compatible object storage bucket.
//
// ## Example Usage
//
// ### Basic Bucket
//
// ```go
// package main
//
// import (
//
//	"github.com/AdrianSilaghi/pulumi-danubedata/sdk/go/danubedata"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			assets, err := danubedata.NewStorageBucket(ctx, "assets", &danubedata.StorageBucketArgs{
//				Region: pulumi.String("fsn1"),
//			})
//			if err != nil {
//				return err
//			}
//			ctx.Export("bucketEndpoint", assets.EndpointUrl)
//			return nil
//		})
//	}
//
// ```
//
// ### Bucket with Versioning
//
// ```go
// package main
//
// import (
//
//	"github.com/AdrianSilaghi/pulumi-danubedata/sdk/go/danubedata"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := danubedata.NewStorageBucket(ctx, "backups", &danubedata.StorageBucketArgs{
//				Region:            pulumi.String("fsn1"),
//				VersioningEnabled: pulumi.Bool(true),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ### Public Bucket
//
// ```go
// package main
//
// import (
//
//	"github.com/AdrianSilaghi/pulumi-danubedata/sdk/go/danubedata"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := danubedata.NewStorageBucket(ctx, "public", &danubedata.StorageBucketArgs{
//				PublicAccess: pulumi.Bool(true),
//				Region:       pulumi.String("fsn1"),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ### Complete Configuration
//
// ```go
// package main
//
// import (
//
//	"github.com/AdrianSilaghi/pulumi-danubedata/sdk/go/danubedata"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := danubedata.NewStorageBucket(ctx, "data", &danubedata.StorageBucketArgs{
//				DisplayName:       pulumi.String("Application Data"),
//				EncryptionEnabled: pulumi.Bool(true),
//				PublicAccess:      pulumi.Bool(false),
//				Region:            pulumi.String("fsn1"),
//				VersioningEnabled: pulumi.Bool(true),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Pricing
//
// - Base: EUR 3.99/month
// - Includes: 1TB storage + 1TB egress traffic
// - Overage: EUR 0.01/GB for storage, EUR 0.01/GB for egress
//
// ## Import
//
// Storage buckets can be imported using their ID:
//
// bash
//
// ```sh
// $ pulumi import danubedata:index/storageBucket:StorageBucket example bucket-abc123
// ```
type StorageBucket struct {
	pulumi.CustomResourceState

	// Creation timestamp.
	CreatedAt pulumi.StringOutput `pulumi:"createdAt"`
	// Human-readable display name for the bucket.
	DisplayName pulumi.StringPtrOutput `pulumi:"displayName"`
	// Whether server-side encryption is enabled.
	EncryptionEnabled pulumi.BoolOutput `pulumi:"encryptionEnabled"`
	// Encryption type (none, sse-s3, sse-kms).
	EncryptionType pulumi.StringOutput `pulumi:"encryptionType"`
	// S3-compatible endpoint URL.
	EndpointUrl pulumi.StringOutput `pulumi:"endpointUrl"`
	// Internal bucket name.
	MinioBucketName pulumi.StringOutput `pulumi:"minioBucketName"`
	// Estimated monthly cost.
	MonthlyCost pulumi.Float64Output `pulumi:"monthlyCost"`
	// Monthly cost in cents.
	MonthlyCostCents pulumi.IntOutput `pulumi:"monthlyCostCents"`
	// Name of the storage bucket. Must follow S3 bucket naming rules (3-63 chars, lowercase alphanumeric with hyphens).
	Name pulumi.StringOutput `pulumi:"name"`
	// Number of objects.
	ObjectCount pulumi.IntOutput `pulumi:"objectCount"`
	// Whether the bucket has public read access enabled.
	PublicAccess pulumi.BoolOutput `pulumi:"publicAccess"`
	// Region for the storage bucket (fsn1).
	Region pulumi.StringOutput `pulumi:"region"`
	// Current size in bytes.
	SizeBytes pulumi.IntOutput `pulumi:"sizeBytes"`
	// Current status.
	Status   pulumi.StringOutput            `pulumi:"status"`
	Timeouts StorageBucketTimeoutsPtrOutput `pulumi:"timeouts"`
	// Timestamp when the bucket was last updated.
	UpdatedAt pulumi.StringOutput `pulumi:"updatedAt"`
	// Whether object versioning is enabled.
	VersioningEnabled pulumi.BoolOutput `pulumi:"versioningEnabled"`
}

// NewStorageBucket registers a new resource with the given unique name, arguments, and options.
func NewStorageBucket(ctx *pulumi.Context,
	name string, args *StorageBucketArgs, opts ...pulumi.ResourceOption) (*StorageBucket, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Region == nil {
		return nil, errors.New("invalid value for required argument 'Region'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource StorageBucket
	err := ctx.RegisterResource("danubedata:index/storageBucket:StorageBucket", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetStorageBucket gets an existing StorageBucket resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetStorageBucket(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *StorageBucketState, opts ...pulumi.ResourceOption) (*StorageBucket, error) {
	var resource StorageBucket
	err := ctx.ReadResource("danubedata:index/storageBucket:StorageBucket", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering StorageBucket resources.
type storageBucketState struct {
	// Creation timestamp.
	CreatedAt *string `pulumi:"createdAt"`
	// Human-readable display name for the bucket.
	DisplayName *string `pulumi:"displayName"`
	// Whether server-side encryption is enabled.
	EncryptionEnabled *bool `pulumi:"encryptionEnabled"`
	// Encryption type (none, sse-s3, sse-kms).
	EncryptionType *string `pulumi:"encryptionType"`
	// S3-compatible endpoint URL.
	EndpointUrl *string `pulumi:"endpointUrl"`
	// Internal bucket name.
	MinioBucketName *string `pulumi:"minioBucketName"`
	// Estimated monthly cost.
	MonthlyCost *float64 `pulumi:"monthlyCost"`
	// Monthly cost in cents.
	MonthlyCostCents *int `pulumi:"monthlyCostCents"`
	// Name of the storage bucket. Must follow S3 bucket naming rules (3-63 chars, lowercase alphanumeric with hyphens).
	Name *string `pulumi:"name"`
	// Number of objects.
	ObjectCount *int `pulumi:"objectCount"`
	// Whether the bucket has public read access enabled.
	PublicAccess *bool `pulumi:"publicAccess"`
	// Region for the storage bucket (fsn1).
	Region *string `pulumi:"region"`
	// Current size in bytes.
	SizeBytes *int `pulumi:"sizeBytes"`
	// Current status.
	Status   *string                `pulumi:"status"`
	Timeouts *StorageBucketTimeouts `pulumi:"timeouts"`
	// Timestamp when the bucket was last updated.
	UpdatedAt *string `pulumi:"updatedAt"`
	// Whether object versioning is enabled.
	VersioningEnabled *bool `pulumi:"versioningEnabled"`
}

type StorageBucketState struct {
	// Creation timestamp.
	CreatedAt pulumi.StringPtrInput
	// Human-readable display name for the bucket.
	DisplayName pulumi.StringPtrInput
	// Whether server-side encryption is enabled.
	EncryptionEnabled pulumi.BoolPtrInput
	// Encryption type (none, sse-s3, sse-kms).
	EncryptionType pulumi.StringPtrInput
	// S3-compatible endpoint URL.
	EndpointUrl pulumi.StringPtrInput
	// Internal bucket name.
	MinioBucketName pulumi.StringPtrInput
	// Estimated monthly cost.
	MonthlyCost pulumi.Float64PtrInput
	// Monthly cost in cents.
	MonthlyCostCents pulumi.IntPtrInput
	// Name of the storage bucket. Must follow S3 bucket naming rules (3-63 chars, lowercase alphanumeric with hyphens).
	Name pulumi.StringPtrInput
	// Number of objects.
	ObjectCount pulumi.IntPtrInput
	// Whether the bucket has public read access enabled.
	PublicAccess pulumi.BoolPtrInput
	// Region for the storage bucket (fsn1).
	Region pulumi.StringPtrInput
	// Current size in bytes.
	SizeBytes pulumi.IntPtrInput
	// Current status.
	Status   pulumi.StringPtrInput
	Timeouts StorageBucketTimeoutsPtrInput
	// Timestamp when the bucket was last updated.
	UpdatedAt pulumi.StringPtrInput
	// Whether object versioning is enabled.
	VersioningEnabled pulumi.BoolPtrInput
}

func (StorageBucketState) ElementType() reflect.Type {
	return reflect.TypeOf((*storageBucketState)(nil)).Elem()
}

type storageBucketArgs struct {
	// Human-readable display name for the bucket.
	DisplayName *string `pulumi:"displayName"`
	// Whether server-side encryption is enabled.
	EncryptionEnabled *bool `pulumi:"encryptionEnabled"`
	// Encryption type (none, sse-s3, sse-kms).
	EncryptionType *string `pulumi:"encryptionType"`
	// Name of the storage bucket. Must follow S3 bucket naming rules (3-63 chars, lowercase alphanumeric with hyphens).
	Name *string `pulumi:"name"`
	// Whether the bucket has public read access enabled.
	PublicAccess *bool `pulumi:"publicAccess"`
	// Region for the storage bucket (fsn1).
	Region   string                 `pulumi:"region"`
	Timeouts *StorageBucketTimeouts `pulumi:"timeouts"`
	// Whether object versioning is enabled.
	VersioningEnabled *bool `pulumi:"versioningEnabled"`
}

// The set of arguments for constructing a StorageBucket resource.
type StorageBucketArgs struct {
	// Human-readable display name for the bucket.
	DisplayName pulumi.StringPtrInput
	// Whether server-side encryption is enabled.
	EncryptionEnabled pulumi.BoolPtrInput
	// Encryption type (none, sse-s3, sse-kms).
	EncryptionType pulumi.StringPtrInput
	// Name of the storage bucket. Must follow S3 bucket naming rules (3-63 chars, lowercase alphanumeric with hyphens).
	Name pulumi.StringPtrInput
	// Whether the bucket has public read access enabled.
	PublicAccess pulumi.BoolPtrInput
	// Region for the storage bucket (fsn1).
	Region   pulumi.StringInput
	Timeouts StorageBucketTimeoutsPtrInput
	// Whether object versioning is enabled.
	VersioningEnabled pulumi.BoolPtrInput
}

func (StorageBucketArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*storageBucketArgs)(nil)).Elem()
}

type StorageBucketInput interface {
	pulumi.Input

	ToStorageBucketOutput() StorageBucketOutput
	ToStorageBucketOutputWithContext(ctx context.Context) StorageBucketOutput
}

func (*StorageBucket) ElementType() reflect.Type {
	return reflect.TypeOf((**StorageBucket)(nil)).Elem()
}

func (i *StorageBucket) ToStorageBucketOutput() StorageBucketOutput {
	return i.ToStorageBucketOutputWithContext(context.Background())
}

func (i *StorageBucket) ToStorageBucketOutputWithContext(ctx context.Context) StorageBucketOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StorageBucketOutput)
}

// StorageBucketArrayInput is an input type that accepts StorageBucketArray and StorageBucketArrayOutput values.
// You can construct a concrete instance of `StorageBucketArrayInput` via:
//
//	StorageBucketArray{ StorageBucketArgs{...} }
type StorageBucketArrayInput interface {
	pulumi.Input

	ToStorageBucketArrayOutput() StorageBucketArrayOutput
	ToStorageBucketArrayOutputWithContext(context.Context) StorageBucketArrayOutput
}

type StorageBucketArray []StorageBucketInput

func (StorageBucketArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*StorageBucket)(nil)).Elem()
}

func (i StorageBucketArray) ToStorageBucketArrayOutput() StorageBucketArrayOutput {
	return i.ToStorageBucketArrayOutputWithContext(context.Background())
}

func (i StorageBucketArray) ToStorageBucketArrayOutputWithContext(ctx context.Context) StorageBucketArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StorageBucketArrayOutput)
}

// StorageBucketMapInput is an input type that accepts StorageBucketMap and StorageBucketMapOutput values.
// You can construct a concrete instance of `StorageBucketMapInput` via:
//
//	StorageBucketMap{ "key": StorageBucketArgs{...} }
type StorageBucketMapInput interface {
	pulumi.Input

	ToStorageBucketMapOutput() StorageBucketMapOutput
	ToStorageBucketMapOutputWithContext(context.Context) StorageBucketMapOutput
}

type StorageBucketMap map[string]StorageBucketInput

func (StorageBucketMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*StorageBucket)(nil)).Elem()
}

func (i StorageBucketMap) ToStorageBucketMapOutput() StorageBucketMapOutput {
	return i.ToStorageBucketMapOutputWithContext(context.Background())
}

func (i StorageBucketMap) ToStorageBucketMapOutputWithContext(ctx context.Context) StorageBucketMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(StorageBucketMapOutput)
}

type StorageBucketOutput struct{ *pulumi.OutputState }

func (StorageBucketOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**StorageBucket)(nil)).Elem()
}

func (o StorageBucketOutput) ToStorageBucketOutput() StorageBucketOutput {
	return o
}

func (o StorageBucketOutput) ToStorageBucketOutputWithContext(ctx context.Context) StorageBucketOutput {
	return o
}

// Creation timestamp.
func (o StorageBucketOutput) CreatedAt() pulumi.StringOutput {
	return o.ApplyT(func(v *StorageBucket) pulumi.StringOutput { return v.CreatedAt }).(pulumi.StringOutput)
}

// Human-readable display name for the bucket.
func (o StorageBucketOutput) DisplayName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *StorageBucket) pulumi.StringPtrOutput { return v.DisplayName }).(pulumi.StringPtrOutput)
}

// Whether server-side encryption is enabled.
func (o StorageBucketOutput) EncryptionEnabled() pulumi.BoolOutput {
	return o.ApplyT(func(v *StorageBucket) pulumi.BoolOutput { return v.EncryptionEnabled }).(pulumi.BoolOutput)
}

// Encryption type (none, sse-s3, sse-kms).
func (o StorageBucketOutput) EncryptionType() pulumi.StringOutput {
	return o.ApplyT(func(v *StorageBucket) pulumi.StringOutput { return v.EncryptionType }).(pulumi.StringOutput)
}

// S3-compatible endpoint URL.
func (o StorageBucketOutput) EndpointUrl() pulumi.StringOutput {
	return o.ApplyT(func(v *StorageBucket) pulumi.StringOutput { return v.EndpointUrl }).(pulumi.StringOutput)
}

// Internal bucket name.
func (o StorageBucketOutput) MinioBucketName() pulumi.StringOutput {
	return o.ApplyT(func(v *StorageBucket) pulumi.StringOutput { return v.MinioBucketName }).(pulumi.StringOutput)
}

// Estimated monthly cost.
func (o StorageBucketOutput) MonthlyCost() pulumi.Float64Output {
	return o.ApplyT(func(v *StorageBucket) pulumi.Float64Output { return v.MonthlyCost }).(pulumi.Float64Output)
}

// Monthly cost in cents.
func (o StorageBucketOutput) MonthlyCostCents() pulumi.IntOutput {
	return o.ApplyT(func(v *StorageBucket) pulumi.IntOutput { return v.MonthlyCostCents }).(pulumi.IntOutput)
}

// Name of the storage bucket. Must follow S3 bucket naming rules (3-63 chars, lowercase alphanumeric with hyphens).
func (o StorageBucketOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *StorageBucket) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// Number of objects.
func (o StorageBucketOutput) ObjectCount() pulumi.IntOutput {
	return o.ApplyT(func(v *StorageBucket) pulumi.IntOutput { return v.ObjectCount }).(pulumi.IntOutput)
}

// Whether the bucket has public read access enabled.
func (o StorageBucketOutput) PublicAccess() pulumi.BoolOutput {
	return o.ApplyT(func(v *StorageBucket) pulumi.BoolOutput { return v.PublicAccess }).(pulumi.BoolOutput)
}

// Region for the storage bucket (fsn1).
func (o StorageBucketOutput) Region() pulumi.StringOutput {
	return o.ApplyT(func(v *StorageBucket) pulumi.StringOutput { return v.Region }).(pulumi.StringOutput)
}

// Current size in bytes.
func (o StorageBucketOutput) SizeBytes() pulumi.IntOutput {
	return o.ApplyT(func(v *StorageBucket) pulumi.IntOutput { return v.SizeBytes }).(pulumi.IntOutput)
}

// Current status.
func (o StorageBucketOutput) Status() pulumi.StringOutput {
	return o.ApplyT(func(v *StorageBucket) pulumi.StringOutput { return v.Status }).(pulumi.StringOutput)
}

func (o StorageBucketOutput) Timeouts() StorageBucketTimeoutsPtrOutput {
	return o.ApplyT(func(v *StorageBucket) StorageBucketTimeoutsPtrOutput { return v.Timeouts }).(StorageBucketTimeoutsPtrOutput)
}

// Timestamp when the bucket was last updated.
func (o StorageBucketOutput) UpdatedAt() pulumi.StringOutput {
	return o.ApplyT(func(v *StorageBucket) pulumi.StringOutput { return v.UpdatedAt }).(pulumi.StringOutput)
}

// Whether object versioning is enabled.
func (o StorageBucketOutput) VersioningEnabled() pulumi.BoolOutput {
	return o.ApplyT(func(v *StorageBucket) pulumi.BoolOutput { return v.VersioningEnabled }).(pulumi.BoolOutput)
}

type StorageBucketArrayOutput struct{ *pulumi.OutputState }

func (StorageBucketArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*StorageBucket)(nil)).Elem()
}

func (o StorageBucketArrayOutput) ToStorageBucketArrayOutput() StorageBucketArrayOutput {
	return o
}

func (o StorageBucketArrayOutput) ToStorageBucketArrayOutputWithContext(ctx context.Context) StorageBucketArrayOutput {
	return o
}

func (o StorageBucketArrayOutput) Index(i pulumi.IntInput) StorageBucketOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *StorageBucket {
		return vs[0].([]*StorageBucket)[vs[1].(int)]
	}).(StorageBucketOutput)
}

type StorageBucketMapOutput struct{ *pulumi.OutputState }

func (StorageBucketMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*StorageBucket)(nil)).Elem()
}

func (o StorageBucketMapOutput) ToStorageBucketMapOutput() StorageBucketMapOutput {
	return o
}

func (o StorageBucketMapOutput) ToStorageBucketMapOutputWithContext(ctx context.Context) StorageBucketMapOutput {
	return o
}

func (o StorageBucketMapOutput) MapIndex(k pulumi.StringInput) StorageBucketOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *StorageBucket {
		return vs[0].(map[string]*StorageBucket)[vs[1].(string)]
	}).(StorageBucketOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*StorageBucketInput)(nil)).Elem(), &StorageBucket{})
	pulumi.RegisterInputType(reflect.TypeOf((*StorageBucketArrayInput)(nil)).Elem(), StorageBucketArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*StorageBucketMapInput)(nil)).Elem(), StorageBucketMap{})
	pulumi.RegisterOutputType(StorageBucketOutput{})
	pulumi.RegisterOutputType(StorageBucketArrayOutput{})
	pulumi.RegisterOutputType(StorageBucketMapOutput{})
}
